<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kovu: #CommunityRescue Arena MVP</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Base styles */
        html, body {
            height: 100%; /* Full height */
            width: 100%; /* Full width */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent default touch behaviors */
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a2e;
            color: #e0e0e0;
            display: flex; /* Use flexbox for overall layout */
            justify-content: center;
            align-items: center;
            -webkit-user-select: none; -ms-user-select: none; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px; /* Max width on desktop */
            height: 100%; /* Take full available height */
            padding: 5px;
            box-sizing: border-box;
        }
        #game-container {
            border: 4px solid #4a4a8a;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(74, 74, 138, 0.7);
            position: relative; /* Needed for absolute children */
            width: 100%;
            flex-grow: 1; /* Takes up available vertical space */
            min-height: 200px;
            background: linear-gradient(135deg, #16213e, #0f3460);
            overflow: hidden; /* Clip canvas/elements */
        }
        #gameCanvas { display: block; width: 100%; height: 100%; border-radius: 10px; }
        /* Overlays */
        #intro-overlay, #level-transition-overlay, #win-message, #game-over-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 100; padding: 20px; border-radius: 10px; transition: opacity 0.5s ease; box-sizing: border-box; }
        #intro-overlay { display: flex; opacity: 1; }
        #level-transition-overlay, #win-message, #game-over-overlay { display: none; opacity: 0; }
        .intro-panel { display: none; width: 80%; max-width: 500px; }
        .intro-panel.active { display: block; }
        .intro-panel img { 
            max-width: 100%; 
            width: 100%;
            height: auto; 
            max-height: 60vh; 
            margin-bottom: 20px; 
            border: 2px solid #4a4a8a; 
            border-radius: 8px;
            object-fit: contain;
        }
        /* Add specific styling for slides 3 and 4 */
        #intro-3 img, #intro-4 img {
            max-height: 75vh; /* 25% larger than the default 60vh */
            width: 125%; /* 25% wider */
            margin-left: -12.5%; /* Center the wider image */
        }
        .intro-panel p { font-size: 0.7rem; line-height: 1.4; margin-bottom: 15px; }
        /* Buttons */
        button { font-family: 'Press Start 2P', cursive; background: linear-gradient(45deg, #f95738, #ff8c42); color: white; border: none; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-size: 0.8rem; text-transform: uppercase; transition: transform 0.2s ease, box-shadow 0.2s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); margin-top: 8px; }
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 10px rgba(249, 87, 56, 0.5); }
        button:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
        #skip-intro-button { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            background: rgba(0, 0, 0, 0.5); 
            border: 2px solid #ff8c42; 
            font-size: 0.6rem; 
            padding: 6px 12px; 
            z-index: 101; 
        }
        #skip-intro-button:hover { 
            background: rgba(0, 0, 0, 0.7); 
            border-color: #ff6347; 
        }
        /* UI */
        #ui-container { position: absolute; top: 5px; left: 5px; right: 5px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 50; font-size: 0.6rem; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
        #ui-left, #ui-right { display: flex; flex-direction: column; gap: 4px; }
        #ui-right { align-items: flex-end; }
        #kcc-status, #level-indicator, #approval-meter-container, #objective-display, #enemy-count { background-color: rgba(0, 0, 0, 0.5); padding: 4px 8px; border-radius: 5px; pointer-events: auto; }
        #kcc-status { border: 1px solid rgba(255, 0, 0, 0.5); }
        #kcc-status.live { background-color: rgba(0, 255, 0, 0.7); border-color: rgba(0, 255, 0, 0.5); }
        #kcc-status span { margin-left: 4px; }
        #objective-display { text-align: right; max-width: 150px; white-space: normal; }
        #approval-meter-container { width: 120px; font-size: 0.5rem; padding: 4px; }
        #approval-meter { width: 100%; height: 12px; -webkit-appearance: none; appearance: none; border: 1px solid #4a4a8a; border-radius: 3px; overflow: hidden; }
        #approval-meter::-webkit-progress-bar { background-color: #333; border-radius: 3px; }
        #approval-meter::-webkit-progress-value { background: linear-gradient(90deg, #1e90ff, #00ffff); border-radius: 0px; transition: width 0.3s ease; }
        #approval-meter::-moz-progress-bar { background: linear-gradient(90deg, #1e90ff, #00ffff); border-radius: 3px; transition: width 0.3s ease; }
        #feedback-area { position: absolute; bottom: 5px; right: 5px; display: flex; flex-direction: column; align-items: flex-end; pointer-events: none; z-index: 50; max-height: 60px; overflow: hidden; }
        .feedback-message { background-color: rgba(74, 74, 138, 0.8); color: white; padding: 3px 6px; border-radius: 4px; margin-top: 4px; font-size: 0.5rem; opacity: 1; transition: opacity 1s ease-out, transform 0.5s ease-out; transform: translateX(0); }
        .feedback-message.negative { background-color: rgba(200, 0, 0, 0.8); }
        .feedback-message.fade-out { opacity: 0; transform: translateX(20px); }
        #level-transition-overlay h2, #win-message h2, #game-over-overlay h2 { font-size: 1.2rem; margin-bottom: 10px; }
        #level-transition-overlay p, #win-message p, #game-over-overlay p { font-size: 0.8rem; margin-bottom: 15px; }

        /* Player Invulnerability Flash */
        .player-invulnerable { animation: flash-invulnerable 0.2s infinite alternate; }
        @keyframes flash-invulnerable { from { opacity: 1; } to { opacity: 0.5; } }

        /* Target Zone Styling */
        .target-zone { position: absolute; border: 3px dashed #00ff00; border-radius: 50%; box-shadow: 0 0 15px rgba(0, 255, 0, 0.6); opacity: 0; pointer-events: none; transition: opacity 0.5s ease; z-index: 5; }
        .target-zone.active { opacity: 1; pointer-events: auto; }

        /* Mobile Tutorial Overlay */
        #mobile-tutorial {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 0.8rem;
            z-index: 70;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        /* Hazard Styling (Unchanged) */
        .dogen-hazard { position: absolute; border-radius: 50%; background-color: transparent; pointer-events: none; z-index: 5; opacity: 0; transform: scale(0.9); border: 3px solid transparent; box-shadow: 0 0 0px transparent; transition: opacity 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease, border-color 0.2s ease, background-color 0.2s ease; }
        .dogen-hazard.warning { opacity: 0.8; border-color: #ffd700; transform: scale(0.95); animation: pulse-warning 0.7s infinite alternate; }
        .dogen-hazard.active { opacity: 1; border-style: dashed; border-color: #ff6347; background-color: rgba(255, 99, 71, 0.25); box-shadow: 0 0 25px rgba(255, 99, 71, 0.7); transform: scale(1); animation: none; }
        @keyframes pulse-warning { from { box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); } to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); } }

        /* Styles for Collectibles & Dash Trail (Applied via Canvas) */
        .collectible {}
        .dash-particle {}
        .laser-beam {}
        .disintegration-particle {}

        /* --- Touch Controls --- */
        /* Default (Desktop) - Controls hidden */
        #touch-controls-container { display: none; }

        /* --- Mobile Overrides --- */
        /* Simplified media query for general mobile */
        /* Laser Button Styles */
        #laser-button {
            width: 90px; /* Slightly smaller than joystick */
            height: 90px;
            position: relative;
            pointer-events: auto;
            border-radius: 50%;
            background: none;
            margin-right: 10px;
        }
        .laser-button-inner {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(255, 50, 50, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 15px rgba(255, 50, 50, 0.3);
            transition: all 0.2s ease;
        }
        #laser-button .laser-button-inner {
            background-color: rgba(255, 50, 50, 0.7);
            border-color: rgba(255, 255, 255, 0.8);
            transition: all 0.2s ease;
        }
        
        #laser-button.cooldown .laser-button-inner {
            background-color: rgba(100, 100, 100, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: none;
            animation: pulse-cooldown 1.5s infinite;
        }
        
        @keyframes pulse-cooldown {
            0% { opacity: 0.3; }
            50% { opacity: 0.6; }
            100% { opacity: 0.3; }
        }
        
        #laser-button:active .laser-button-inner {
            background-color: rgba(255, 100, 100, 0.8);
            border-color: rgba(255, 255, 255, 1);
            transform: scale(0.92);
            box-shadow: 0 0 25px rgba(255, 50, 50, 0.5);
            transition: all 0.15s ease;
        }

        @media (max-width: 768px) {
            #game-wrapper {
                 max-height: none; /* Allow full height */
                 padding: 0; /* Remove padding */
            }
            #game-container {
                 border: none; /* Remove border */
                 border-radius: 0; /* Remove rounding */
                 box-shadow: none; /* Remove shadow */
            }
            #gameCanvas {
                 border-radius: 0; /* Remove rounding */
            }

            #touch-controls-container {
                display: flex; /* Show controls on mobile */
                position: absolute; /* Overlay on game container */
                bottom: 0; left: 0; right: 0;
                height: auto; /* Let content determine height */
                padding: 15px; /* Padding around controls */
                z-index: 60; /* Above canvas, below overlays */
                pointer-events: none; /* Container doesn't block */
                background: none;
                justify-content: space-between;
                align-items: flex-end; /* Align controls to bottom */
            }
            /* Joystick Styles */
            #joystick-area {
                width: 130px; /* Slightly larger */
                height: 130px;
                position: relative; pointer-events: auto; border-radius: 50%; background: none;
            }
            #joystick-base { position: absolute; width: 100%; height: 100%; border-radius: 50%; background-color: rgba(80, 80, 80, 0.4); border: 2px solid rgba(255, 255, 255, 0.4); top: 0; left: 0; }
            #joystick-knob { position: absolute; width: 60px; /* Slightly larger */ height: 60px; background-color: rgba(200, 200, 200, 0.6); border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: background-color 0.1s ease; }
            #joystick-area.active #joystick-knob { background-color: rgba(255, 255, 255, 0.7); }

            /* Game area tap handling */
            #game-container {
                touch-action: none; /* Prevent default touch behaviors */
            }

            #controls-hint { display: none; }
        }

        #tutorial-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 100; padding: 20px; border-radius: 10px; transition: opacity 0.5s ease; box-sizing: border-box; }
        .tutorial-panel { display: none; width: 80%; max-width: 500px; }
        .tutorial-panel.active { display: block; }
        .tutorial-panel img { max-width: 100%; height: auto; max-height: 150px; margin-bottom: 10px; border: 2px solid #4a4a8a; border-radius: 8px; }
        .tutorial-panel p { font-size: 0.7rem; line-height: 1.4; margin-bottom: 15px; }
        .hazard-demo { position: absolute; width: 100px; height: 100px; border-radius: 50%; background-color: rgba(255, 0, 0, 0.3); border: 3px dashed #ff0000; box-shadow: 0 0 15px rgba(255, 0, 0, 0.6); animation: pulse-hazard 1s infinite alternate; }
        @keyframes pulse-hazard { from { transform: scale(0.9); opacity: 0.7; } to { transform: scale(1.1); opacity: 1; } }

    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-container">
            <div id="intro-overlay">
                 <div class="intro-panel active" id="intro-1" data-panel="1">
                     <button id="skip-intro-button">Skip Intro & Tutorial</button>
                     <img src="slide1.jpg" alt="Abandoned Kovu" onerror="this.src='https://placehold.co/400x200/333333/cccccc?text=Image+Error'">
                     <p>Abandoned... like a delisted coin. Colors faded, feeling worthless...</p>
                     <button data-next="2">Next</button>
                 </div>
                 <div class="intro-panel" id="intro-2" data-panel="2">
                     <img src="slide2.jpg" alt="KCC Rescue" onerror="this.onerror=null; this.src='https://placehold.co/400x200/555555/dddddd?text=KCC+Rescue'">
                     <p>"Subject Kovu located. Vital signs critical. Initiating community rescue protocol." The KCC found me.</p>
                     <button data-next="3">Next</button>
                 </div>
                 <div class="intro-panel" id="intro-3" data-panel="3">
                     <img src="slide3.jpg" alt="Upgrade Bay" onerror="this.onerror=null; this.src='https://placehold.co/400x200/1a1a2e/00ffff?text=Upgrade+Bay'">
                     <p>"The Community pooled resources... gave you upgrades! This 'Community Link' keeps us connected. Think of it as your personal live feed!"</p>
                     <button data-next="4">Next</button>
                 </div>
                 <div class="intro-panel" id="intro-4" data-panel="4">
                     <img src="slide4.jpg" alt="Entering Arena" onerror="this.onerror=null; this.src='https://placehold.co/400x200/0f3460/ffffff?text=Entering+Arena'">
                     <p>"Go out there, engage, climb the ranks! We'll be watching. Make us proud!" ... A second chance?</p>
                     <button data-next="start">Enter the Arena!</button>
                 </div>
            </div>
            <div id="level-transition-overlay"><h2>Level Complete!</h2><p>Prepare for the next challenge...</p></div>
            <div id="game-over-overlay"><h2>Game Over!</h2><p>Community approval dropped too low. Try again?</p><button id="restart-button">Restart</button></div>
            <div id="tutorial-overlay" style="display: none;">
                <div class="tutorial-panel" id="tutorial-1" data-panel="1">
                    <h2>Welcome to the Arena!</h2>
                    <p>Your goal is to collect data packets while avoiding hazards and rivals.</p>
                    <div class="hazard-demo" style="top: 30%; left: 50%; transform: translate(-50%, -50%);"></div>
                    <p>Watch out for red hazard zones! They'll drain your approval rating.</p>
                    <button data-next="2">Next</button>
                </div>
                <div class="tutorial-panel" id="tutorial-2" data-panel="2">
                    <h2>Controls</h2>
                    <p>Use the joystick or arrow keys to move.</p>
                    <p>Tap the screen or press SPACE to dash away from danger.</p>
                    <p>Use the laser button or press E to destroy rivals.</p>
                    <button data-next="3">Next</button>
                </div>
                <div class="tutorial-panel" id="tutorial-3" data-panel="3">
                    <h2>Gameplay Tips</h2>
                    <p>Collect all data packets to activate the target zone.</p>
                    <p>Destroy rivals to clear your path.</p>
                    <p>Keep your approval rating above zero!</p>
                    <button data-next="start">Begin!</button>
                </div>
            </div>
            <canvas id="gameCanvas"></canvas>
            <div id="ui-container">
                 <div id="ui-left"> <div id="kcc-status">ðŸ”´<span>OFFLINE</span></div>
                      <div id="level-indicator">Level: 1</div>
                 </div>
                 <div id="ui-right"> <div id="approval-meter-container"> Community Approval: <progress id="approval-meter" value="10" max="100"></progress> </div>
                      <div id="objective-display">Objective: Collect Data! (0/0)</div>
                      <div id="enemy-count">Enemies: 0/0</div>
                 </div>
            </div>
            <div id="feedback-area"></div>
            <div id="win-message"> <h2>All Levels Complete!</h2> <p>#KovuWins! The Community is ecstatic!</p> <button id="play-again-button">Play Again?</button> </div>

            <div id="mobile-tutorial">Tap on screen to dash</div>

             <div id="touch-controls-container">
                  <div id="joystick-area">
                      <div id="joystick-base"></div>
                      <div id="joystick-knob"></div>
                  </div>
                  <div id="laser-button">
                      <div class="laser-button-inner"></div>
                  </div>
              </div>
        </div>
        <div id="controls-hint">Controls: Arrow Keys/WASD/Joystick, Space/Touch to Dash, E/Touch to Fire Laser</div>
    </div>


    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const introOverlay = document.getElementById('intro-overlay');
        const winMessage = document.getElementById('win-message');
        const levelTransitionOverlay = document.getElementById('level-transition-overlay');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const kccStatusElement = document.getElementById('kcc-status');
        const objectiveDisplay = document.getElementById('objective-display');
        const approvalMeter = document.getElementById('approval-meter');
        const feedbackArea = document.getElementById('feedback-area');
        const levelIndicator = document.getElementById('level-indicator');
        // Joystick Elements
        const joystickArea = document.getElementById('joystick-area');
        const joystickKnob = document.getElementById('joystick-knob');
        let canvasWidth, canvasHeight;
        let gameState = 'intro';
        let keys = {};
        let animationFrameId;
        let currentLevel = 1;
        let collectiblesCollected = 0;
        let totalCollectibles = 0;
        let isTargetZoneActive = false;
        let tutorialActive = true;

        // Joystick state variables
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickRadius = 0;
        let knobRadius = 0;
        let maxJoystickDist = 0;
        let joystickDx = 0;
        let joystickDy = 0;
        // let joystickMagnitude = 0; // No longer used for speed scaling
        let joystickDimensionsCalculated = false;

        // Delta Time variables
        let lastTimestamp = 0;

        // --- Level Configuration --- (Unchanged)
        const levelConfigs = [ 
            { level: 1, numRivals: 3, numCollectibles: 5, targetXRatio: 0.85, targetYRatio: 0.8, objectiveText: "Objective: Reach the Viral Stage!", rivalSpeedMultiplier: 1.0, rivalHazardCooldownBase: 3500 }, 
            { level: 2, numRivals: 4, numCollectibles: 7, targetXRatio: 0.15, targetYRatio: 0.2, objectiveText: "Objective: Reach the Upload Point!", rivalSpeedMultiplier: 1.1, rivalHazardCooldownBase: 3000 }, 
            { level: 3, numRivals: 5, numCollectibles: 8, targetXRatio: 0.5, targetYRatio: 0.15, objectiveText: "Objective: Secure the Data Core!", rivalSpeedMultiplier: 1.15, rivalHazardCooldownBase: 2800 }, 
            { level: 4, numRivals: 6, numCollectibles: 10, targetXRatio: 0.8, targetYRatio: 0.2, objectiveText: "Objective: Final Broadcast Point!", rivalSpeedMultiplier: 1.2, rivalHazardCooldownBase: 2500 },
            { level: 5, numRivals: 7, numCollectibles: 12, targetXRatio: 0.2, targetYRatio: 0.1, objectiveText: "Objective: Elite Data Extraction!", rivalSpeedMultiplier: 1.3, rivalHazardCooldownBase: 2200 },
            { level: 6, numRivals: 8, numCollectibles: 15, targetXRatio: 0.7, targetYRatio: 0.1, objectiveText: "Objective: Ultimate Community Challenge!", rivalSpeedMultiplier: 1.4, rivalHazardCooldownBase: 2000 }
        ];

        // --- Sound Effects Setup --- (Unchanged)
        let soundsReady = false; let synths = {};
        function setupSounds() { 
            try { 
                // Create a single transport for all sounds
                Tone.Transport.start();
                
                // Initialize synths with mobile-friendly settings
                synths.dash = new Tone.Synth({ 
                    oscillator: { type: 'triangle' }, 
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 },
                    volume: -8 // Reduced volume for mobile
                }).toDestination(); 
                
                synths.collect = new Tone.Synth({ 
                    oscillator: { type: 'sine' }, 
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.2 },
                    volume: -6
                }).toDestination(); 
                
                synths.win = new Tone.Synth({ 
                    oscillator: { type: 'sawtooth' }, 
                    envelope: { attack: 0.05, decay: 0.2, sustain: 0.3, release: 0.5 },
                    volume: -4
                }).toDestination(); 
                
                synths.feedbackPositive = new Tone.PluckSynth({
                    volume: -8
                }).toDestination(); 
                
                synths.feedbackNegative = new Tone.NoiseSynth({ 
                    noise: { type: 'pink' }, 
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 },
                    volume: -12
                }).toDestination(); 
                
                synths.hazardWarn = new Tone.Synth({ 
                    oscillator: { type: 'pulse', width: 0.3 }, 
                    envelope: { attack: 0.01, decay: 0.05, sustain: 0.1, release: 0.1 },
                    volume: -10
                }).toDestination(); 
                
                synths.laserFire = new Tone.Synth({ 
                    oscillator: { type: 'pwm', modulationFrequency: 0.2 }, 
                    envelope: { attack: 0.005, decay: 0.2, sustain: 0.01, release: 0.1 },
                    volume: -6
                }).toDestination(); 
                
                synths.rivalDestroyed = new Tone.MetalSynth({ 
                    frequency: 100, 
                    envelope: { attack: 0.01, decay: 0.4, release: 0.2 }, 
                    harmonicity: 5.1, 
                    modulationIndex: 32, 
                    resonance: 4000, 
                    octaves: 1.5,
                    volume: -8
                }).toDestination(); 
                
                synths.playerHit = new Tone.Synth({ 
                    oscillator: { type: 'square' }, 
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 },
                    volume: -10
                }).toDestination(); 
                
                synths.gameOver = new Tone.Synth({ 
                    oscillator: { type: 'fatsawtooth', count: 3, spread: 30 }, 
                    envelope: { attack: 0.1, decay: 0.5, sustain: 0.1, release: 0.8 },
                    volume: -6
                }).toDestination(); 
                
                soundsReady = true; 
                console.log("Tone.js Synths Initialized"); 
            } catch (error) { 
                console.error("Error initializing Tone.js:", error); 
                soundsReady = false;
            } 
        }

        function playSound(type, note = null, duration = '8n') { 
            if (!soundsReady || !synths[type]) return; 
            
            try {
                // Use Tone.Transport for precise timing
                const now = Tone.now();
                
                if (type === 'feedbackNegative' || type === 'dash' || type === 'hazardWarn' || 
                    type === 'laserFire' || type === 'rivalDestroyed' || type === 'playerHit' || 
                    type === 'gameOver') {
                    
                    if (type === 'feedbackNegative') {
                        synths[type].triggerAttackRelease(duration, now);
                    } else if (type === 'dash') {
                        synths[type].triggerAttackRelease('C4', duration, now);
                    } else if (type === 'hazardWarn') {
                        synths[type].triggerAttackRelease('A4', '16n', now);
                    } else if (type === 'laserFire') {
                        synths[type].triggerAttackRelease('G5', '16n', now);
                    } else if (type === 'rivalDestroyed') {
                        synths[type].triggerAttackRelease(now);
                    } else if (type === 'playerHit') {
                        synths[type].triggerAttackRelease('C3', '8n', now);
                    } else if (type === 'gameOver') {
                        synths[type].triggerAttackRelease('C2', '1n', now);
                    }
                } else if (note) {
                    synths[type].triggerAttackRelease(note, duration, now);
                }
            } catch (error) {
                console.error(`Error playing sound ${type}:`, error);
            }
        }

        // Background images
        let backgroundImage = new Image(); // Level 1 - bgcity.jpg
        let backgroundImage2 = new Image(); // Level 2 - bg2.jpg
        let backgroundImage3 = new Image(); // Level 3 - memeversebg.jpg
        let backgroundImage4 = new Image(); // Level 4 - sydney.jpg
        let backgroundImage5 = new Image(); // Level 5 - whitehousebg.jpg
        let backgroundImage6 = new Image(); // Level 6 - marsbg.jpg
        
        // Track image loading status
        const imageLoadStatus = {
            bg1: false,
            bg2: false,
            bg3: false,
            bg4: false,
            bg5: false,
            bg6: false
        };
        
        // Function to handle image loading with retries
        function loadImageWithRetry(img, src, statusKey, maxRetries = 2) {
            return new Promise((resolve) => {
                let retries = 0;
                
                const loadImage = () => {
                    img.onload = () => {
                        console.log(`Background image ${statusKey} loaded successfully`);
                        imageLoadStatus[statusKey] = true;
                        resolve();
                    };
                    
                    img.onerror = () => {
                        console.error(`Failed to load background image ${statusKey}: ${src}`);
                        imageLoadStatus[statusKey] = false;
                        
                        if (retries < maxRetries) {
                            retries++;
                            console.log(`Retrying load for ${statusKey} (attempt ${retries})`);
                            setTimeout(() => {
                                img.src = src;
                            }, 1000 * retries);
                        } else {
                            resolve();
                        }
                    };
                    
                    img.src = src;
                };
                
                loadImage();
            });
        }
        
        // Load images with error handling and retries
        async function loadBackgroundImages() {
            try {
                await Promise.all([
                    loadImageWithRetry(backgroundImage, 'bgcity.jpg', 'bg1'),
                    loadImageWithRetry(backgroundImage2, 'bg2.jpg', 'bg2'),
                    loadImageWithRetry(backgroundImage3, 'memeversebg.jpg', 'bg3'),
                    loadImageWithRetry(backgroundImage4, 'sydney.jpg', 'bg4'),
                    loadImageWithRetry(backgroundImage5, 'whitehousebg.jpg', 'bg5'),
                    loadImageWithRetry(backgroundImage6, 'marsbg.jpg', 'bg6')
                ]);
                console.log("All background images loaded or failed gracefully");
            } catch (error) {
                console.error("Error during background image loading:", error);
            }
        }
        
        // Call loadBackgroundImages when the window loads
        window.addEventListener('load', loadBackgroundImages);

        // --- Game Objects --- (Unchanged definitions)
        const player = {
            x: 50, y: 50,
            width: window.innerWidth <= 768 ? 84 : 84, // 30% larger on mobile (64 * 1.3 â‰ˆ 84)
            height: window.innerWidth <= 768 ? 84 : 84, // 30% larger on mobile (64 * 1.3 â‰ˆ 84)
            speed: window.innerWidth <= 768 ? 200 : 180, /* Slightly faster on mobile for better control */
            isDashing: false, dashCooldown: 1500, lastDashTime: 0, dashDuration: 250, dashParticles: [],
            laserCooldown: 1000, lastLaserTime: 0, isFiringLaser: false, laserDuration: 150, laserRange: 300, laserWidth: 5,
            lastMoveDx: 1, lastMoveDy: 0, isInvulnerable: false, invulnerabilityDuration: 1000, lastHitTime: 0,
            img: null,
            loadImage: async function() {
                return new Promise((resolve) => {
                    this.img = new Image();
                    this.img.onload = () => resolve();
                    this.img.onerror = () => {
                        console.error("Failed to load player image");
                        resolve();
                    };
                    this.img.src = 'kovu.PNG';
                });
            }
        };
        // Initial image load
        player.loadImage();
        const rivals = []; const rivalBaseSpeed = 60; /* Base speed in pixels per second */ const rivalHazardRadius = 50; const rivalHazardWarningDuration = 800; const rivalHazardActiveDuration = 1000;
        // Add FUD projectile system
        const fudProjectiles = [];
        const fudProjectileSpeed = 100; // pixels per second
        const fudProjectileSize = 20;
        const fudProjectileDamage = 10; // 10% damage

        // Array of rival images
        const rivalImages = [
            { img: new Image(), src: 'meme1.PNG' },
            { img: new Image(), src: 'meme3.PNG' },
            { img: new Image(), src: 'meme4.PNG' },
        ];
        // Load all rival images with error handling
        rivalImages.forEach(rivalImg => {
            rivalImg.img.onload = () => {
                console.log(`Rival image loaded successfully: ${rivalImg.src}`);
            };
            rivalImg.img.onerror = () => {
                console.error(`Failed to load rival image: ${rivalImg.src}`);
                // Set a fallback color for failed images
                rivalImg.loadError = true;
            };
            rivalImg.img.src = rivalImg.src;
        });
        // Function to get random rival image
        function getRandomRivalImage() {
            const randomIndex = Math.floor(Math.random() * rivalImages.length);
            return rivalImages[randomIndex].img;
        }
        const targetZone = { x: 600, y: 400, radius: 40, color: 'rgba(0, 255, 0, 0.3)', borderColor: '#00ff00', element: null };
        const collectibles = []; 
        const collectibleRadius = 15; // Increased radius for coins
        const collectibleWidth = 20; // Increased width for coins
        const collectibleHeight = 20; // Increased height for coins
        const particles = [];
        const feedbackMessages = [ /* ... Unchanged ... */ { trigger: 'dash', text: '#KovuBoost!', approval: 3, sound: 'dash' }, { trigger: 'halfway', text: 'Looking good! #Progress', approval: 5, sound: 'feedbackPositive', note: 'G4' }, { trigger: 'dodge', text: 'Nice dodge! #Skillz', approval: 4, sound: 'feedbackPositive', note: 'A4' }, { trigger: 'hazard_hit', text: 'Hazard Hit! Approval Lost!', approval: -15, sound: 'playerHit', negative: true }, { trigger: 'rival_collision', text: 'Collision! Ouch!', approval: -10, sound: 'playerHit', negative: true }, { trigger: 'collect', text: 'Data Packet! +Approval!', approval: 5, sound: 'collect', note: 'C5' }, { trigger: 'destroy_rival', text: 'Rival Deleted! #LaserFocus', approval: 10, sound: 'rivalDestroyed' }, { trigger: 'win', text: '#Victory! Community Morale Soaring!', approval: 20, sound: 'win', note: 'C5' }, { trigger: 'fud_hit', text: 'FUD Attack! -10% Approval!', approval: -10, sound: 'playerHit', negative: true } ];
        let halfwayReached = false;

        // --- Initialization --- (Unchanged functions: loadSvg, createDisintegrationEffect)
        function loadSvg(svgString, width, height) { return new Promise((resolve) => { const blob = new Blob([svgString], { type: 'image/svg+xml' }); const url = URL.createObjectURL(blob); const img = new Image(); img.onload = () => { URL.revokeObjectURL(url); resolve(img); }; img.onerror = () => { console.error("Failed to load SVG image"); resolve(null); }; img.width = width; img.height = height; img.src = url; }); }
        function createDisintegrationEffect(x, y, count = 30) { // Reduced particle count
                            // Simple burst effect without shadows
                            ctx.beginPath();
                            ctx.arc(x, y, 30, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 200, 50, 0.4)';
                            ctx.fill();
        
                            // Single wave of optimized particles
                            const maxParticles = Math.min(count, 30); // Cap maximum particles
                            for (let i = 0; i < maxParticles; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = Math.random() * 4 + 2;
                                particles.push({
                                    x: x,
                                    y: y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    radius: Math.random() * 4 + 2,
                                    color: `rgba(255, ${200 + Math.random() * 55}, 100, 0.8)`,
                                    life: 40,
                                    initialLife: 40
                                });
                            }
        
                            // Remove oldest particles if we exceed the limit
                            const particleLimit = 100;
                            if (particles.length > particleLimit) {
                                particles.splice(0, particles.length - particleLimit);
                            }
        }
        function spawnCollectibles(levelConf) {
            collectibles.length = 0;
            totalCollectibles = levelConf.numCollectibles;
            collectiblesCollected = 0;
            isTargetZoneActive = false;

            // Check if we're on mobile
            const isMobile = window.innerWidth <= 768;

            // Define UI-safe zones where collectibles cannot spawn
            const uiSafeZones = isMobile ? [
                // Mobile layout
                // Top UI area (level indicator and KCC status)
                { x: 0, y: 0, width: canvasWidth * 0.3, height: 50 },
                // Right UI area (approval meter, objective, enemy count)
                { x: canvasWidth * 0.7, y: 0, width: canvasWidth * 0.3, height: 100 },
                // Bottom touch controls area
                { x: 0, y: canvasHeight - 150, width: canvasWidth, height: 150 },
                // Bottom feedback area
                { x: canvasWidth * 0.7, y: canvasHeight - 100, width: canvasWidth * 0.3, height: 100 }
            ] : [
                // Desktop layout
                // Top UI area (level indicator and KCC status)
                { x: 0, y: 0, width: canvasWidth * 0.3, height: 50 },
                // Right UI area (approval meter, objective, enemy count)
                { x: canvasWidth * 0.7, y: 0, width: canvasWidth * 0.3, height: 100 },
                // Bottom feedback area
                { x: canvasWidth * 0.7, y: canvasHeight - 100, width: canvasWidth * 0.3, height: 100 }
            ];

            // Define safe margins from edges
            const topMargin = 60; // Increased from 40
            const bottomMargin = isMobile ? 180 : 80; // Increased margins
            const sideMargin = 40; // New side margin

            // Create a grid system for more even distribution
            const gridCols = 8;
            const gridRows = 6;
            const cellWidth = (canvasWidth - 2 * sideMargin) / gridCols;
            const cellHeight = (canvasHeight - topMargin - bottomMargin) / gridRows;

            // Track used grid cells to prevent clustering
            const usedCells = new Set();

            for (let i = 0; i < totalCollectibles; i++) {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 100) {
                    attempts++;
                    
                    // Select a random grid cell
                    const gridX = Math.floor(Math.random() * gridCols);
                    const gridY = Math.floor(Math.random() * gridRows);
                    const cellKey = `${gridX},${gridY}`;
                    
                    // Skip if cell already used
                    if (usedCells.has(cellKey)) continue;
                    
                    // Calculate potential position within the cell
                    const potentialX = sideMargin + gridX * cellWidth + Math.random() * cellWidth;
                    const potentialY = topMargin + gridY * cellHeight + Math.random() * cellHeight;
                    
                    // Skip if in UI-safe zones
                    let inUISafeZone = false;
                    for (const zone of uiSafeZones) {
                        if (potentialX >= zone.x && 
                            potentialX <= zone.x + zone.width && 
                            potentialY >= zone.y && 
                            potentialY <= zone.y + zone.height) {
                            inUISafeZone = true;
                            break;
                        }
                    }
                    if (inUISafeZone) continue;
                    
                    // Check minimum distance from player start
                    const distToPlayerStart = Math.sqrt(
                        Math.pow(potentialX - canvasWidth / 4, 2) + 
                        Math.pow(potentialY - canvasHeight / 2, 2)
                    );
                    
                    // Check minimum distance from target zone
                    const distToTarget = Math.sqrt(
                        Math.pow(potentialX - targetZone.x, 2) + 
                        Math.pow(potentialY - targetZone.y, 2)
                    );
                    
                    // Check minimum distance from rivals
                    let tooCloseToRival = false;
                    for (const r of rivals) {
                        if (!r.isDestroyed) {
                            const distToRival = Math.sqrt(
                                Math.pow(potentialX - r.startX, 2) + 
                                Math.pow(potentialY - r.startY, 2)
                            );
                            if (distToRival < r.width * 2) {
                                tooCloseToRival = true;
                                break;
                            }
                        }
                    }
                    
                    // Check minimum distance from other collectibles
                    let tooCloseToCollectible = false;
                    for (const c of collectibles) {
                        const distToCollectible = Math.sqrt(
                            Math.pow(potentialX - c.x, 2) + 
                            Math.pow(potentialY - c.y, 2)
                        );
                        if (distToCollectible < collectibleRadius * 4) {
                            tooCloseToCollectible = true;
                            break;
                        }
                    }
                    
                    if (distToPlayerStart > player.width * 2 && 
                        distToTarget > targetZone.radius * 1.5 && 
                        !tooCloseToRival && 
                        !tooCloseToCollectible) {
                        
                        collectibles.push({
                            x: potentialX,
                            y: potentialY,
                            radius: collectibleRadius,
                            collected: false,
                            rotation: 0,
                            rotationSpeed: 0.05 + Math.random() * 0.05,
                            bobOffset: Math.random() * Math.PI * 2,
                            bobSpeed: 0.05 + Math.random() * 0.05
                        });
                        
                        usedCells.add(cellKey);
                        placed = true;
                    }
                }
                
                if (attempts >= 100) {
                    console.warn(`Could not place collectible ${i + 1} after 100 attempts.`);
                }
            }
            
            console.log(`Level ${levelConf.level}: Spawned ${collectibles.length} Collectibles`);
            updateObjectiveText();
        }
        function updateObjectiveText() {
            const levelConf = levelConfigs[currentLevel - 1];
            const enemiesRemaining = rivals.filter(r => !r.isDestroyed).length;
            const totalEnemies = levelConf.numRivals;
            
            if (isTargetZoneActive) {
                objectiveDisplay.textContent = levelConf.objectiveText;
            } else {
                objectiveDisplay.textContent = `Collect Data! (${collectiblesCollected}/${totalCollectibles})`;
            }
            
            // Update enemy count display
            const enemyCountElement = document.getElementById('enemy-count');
            if (enemyCountElement) {
                enemyCountElement.textContent = `Enemies: ${totalEnemies - enemiesRemaining}/${totalEnemies}`;
            }
        }
        async function setupGame(levelIndex) {
            const levelConf = levelConfigs[levelIndex];
            if (!levelConf) {
                console.error("Invalid level index:", levelIndex);
                gameState = 'win';
                winMessage.style.display = 'flex';
                winMessage.style.opacity = 1;
                return;
            }
            console.log(`Setting up Level ${levelConf.level}`);
            currentLevel = levelConf.level;
            canvasWidth = gameContainer.clientWidth;
            canvasHeight = gameContainer.clientHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            levelIndicator.textContent = `Level: ${levelConf.level}`;
            player.x = canvasWidth / 4;
            player.y = canvasHeight / 2;
            player.lastMoveDx = 1;
            player.lastMoveDy = 0;
            targetZone.x = canvasWidth * levelConf.targetXRatio;
            targetZone.y = canvasHeight * levelConf.targetYRatio;
            if (!player.img) player.img = await loadSvg(player.svg, player.width, player.height);
            if (!rivalImages[0].img) rivalImages[0].img = await loadSvg(rivalSvg, 38, 38);
            rivals.length = 0;
            document.querySelectorAll('.dogen-hazard').forEach(el => el.remove());
            particles.length = 0;
            for (let i = 0; i < levelConf.numRivals; i++) {
                const startX = canvasWidth * (0.5 + Math.random() * 0.3);
                const startY = canvasHeight * (0.15 + Math.random() * 0.7);
                const patrolRange = 70 + Math.random() * 60;
                const speed = rivalBaseSpeed * levelConf.rivalSpeedMultiplier * (0.8 + Math.random() * 0.4);
                const hazardCooldown = levelConf.rivalHazardCooldownBase;
                const hazardRandomDelay = Math.random() * 1500;
                const hazardElement = document.createElement('div');
                hazardElement.className = 'dogen-hazard';
                hazardElement.style.width = `${rivalHazardRadius * 2}px`;
                hazardElement.style.height = `${rivalHazardRadius * 2}px`;
                gameContainer.appendChild(hazardElement);
                rivals.push({
                    x: startX,
                    y: startY,
                    width: window.innerWidth <= 768 ? 68 : 57,  // 20% smaller than previous mobile size
                    height: window.innerWidth <= 768 ? 68 : 57, // 20% smaller than previous mobile size
                    speed: speed,
                    direction: Math.random() < 0.5 ? 1 : -1,
                    patrolRange: patrolRange,
                    startX: startX,
                    startY: startY,
                    img: getRandomRivalImage(),
                    hazardActive: false,
                    isInWarning: false,
                    lastHazardTime: Date.now() - Math.random() * hazardCooldown + 2000, // Reduced initial delay to 2 seconds
                    hazardElement: hazardElement,
                    hazardFeedbackGiven: false,
                    dodgeFeedbackGiven: false,
                    isDestroyed: false,
                    hazardCooldown: hazardCooldown,
                    hazardTimer: hazardCooldown + hazardRandomDelay + 2000, // Reduced initial delay to 2 seconds
                    hazardTargetX: 0,
                    hazardTargetY: 0,
                    lastFudShot: 0, // Add FUD shooting timer
                });
            }
            updateObjectiveText(); // Initialize enemy count display
            console.log(`Level ${levelConf.level}: Initialized Rivals Array:`, JSON.parse(JSON.stringify(rivals)));
            if (!targetZone.element) {
                targetZone.element = document.createElement('div');
                targetZone.element.className = 'target-zone';
                gameContainer.appendChild(targetZone.element);
            }
            targetZone.element.style.left = `${targetZone.x - targetZone.radius}px`;
            targetZone.element.style.top = `${targetZone.y - targetZone.radius}px`;
            targetZone.element.style.width = `${targetZone.radius * 2}px`;
            targetZone.element.style.height = `${targetZone.radius * 2}px`;
            targetZone.element.classList.remove('active');
            spawnCollectibles(levelConf);
            joystickDimensionsCalculated = false;
            console.log(`Level ${levelConf.level} setup complete.`);
        }
        window.addEventListener('resize', () => {
            // Update dimensions for mobile/desktop
            if (window.innerWidth <= 768) {
                player.width = player.height = 64;
                player.speed = 200;
                rivals.forEach(rival => {
                    rival.width = rival.height = 68; // 20% smaller than previous mobile size
                });
            } else {
                player.width = player.height = 84;
                player.speed = 180;
                rivals.forEach(rival => {
                    rival.width = rival.height = 57;
                });
            }
            
            // Reload game setup
            if (gameState === 'playing' || gameState === 'level_transition') {
                setupGame(currentLevel - 1);
            }
        });

        // Function to preload all game images
        async function preloadGameImages() {
            console.log("Preloading game images...");
            const imagePromises = [];
            
            // Preload player image
            imagePromises.push(player.loadImage());
            
            // Preload rival images
            rivalImages.forEach(rivalImg => {
                imagePromises.push(new Promise((resolve) => {
                    rivalImg.img.onload = () => {
                        console.log(`Rival image loaded: ${rivalImg.src}`);
                        resolve();
                    };
                    rivalImg.img.onerror = () => {
                        console.error(`Failed to load rival image: ${rivalImg.src}`);
                        resolve(); // Resolve anyway to continue game
                    };
                    // Reload the image
                    rivalImg.img.src = rivalImg.src;
                }));
            });
            
            try {
                await Promise.all(imagePromises);
                console.log("All game images preloaded successfully");
            } catch (error) {
                console.error("Error preloading images:", error);
            }
        }
        // Enhanced intro panel handling with touch support
        function showIntroPanel(panelNumber) {
            console.log("Transitioning to intro panel:", panelNumber);
            
            const currentPanel = document.querySelector('.intro-panel.active');
            const nextPanel = document.querySelector(`.intro-panel[data-panel="${panelNumber}"]`);
            
            if (!nextPanel) {
                console.error("Could not find panel:", panelNumber);
                return;
            }
            
            if (currentPanel) {
                currentPanel.style.opacity = '0';
                setTimeout(() => {
                    currentPanel.style.display = 'none';
                    currentPanel.classList.remove('active');
                    
                    nextPanel.style.display = 'block';
                    nextPanel.offsetHeight;
                    nextPanel.classList.add('active');
                    nextPanel.style.opacity = '1';
                    console.log("Panel transition complete:", nextPanel.dataset.panel);
                }, 300);
            }
        }
        
        function setupIntroTouchHandlers() {
            // Add CSS for smooth transitions
            const style = document.createElement('style');
            style.textContent = `
                .intro-panel {
                    transition: opacity 0.3s ease;
                    opacity: 0;
                    pointer-events: none;
                    display: none;
                }
                .intro-panel.active {
                    opacity: 1;
                    pointer-events: auto;
                    display: block;
                }
                #intro-overlay button {
                    transition: transform 0.2s ease;
                    cursor: pointer;
                    padding: 10px 20px;
                    background: linear-gradient(45deg, #f95738, #ff8c42);
                    border: none;
                    border-radius: 8px;
                    color: white;
                    font-family: 'Press Start 2P', cursive;
                    font-size: 0.8rem;
                    text-transform: uppercase;
                }
                #intro-overlay button:active {
                    transform: scale(0.95);
                }
            `;
            document.head.appendChild(style);
    
            // Set initial panel state
            const initialPanel = document.querySelector('.intro-panel.active');
            if (initialPanel) {
                initialPanel.style.display = 'block';
                initialPanel.style.opacity = '1';
            }
    
            // Handle button clicks
            const introButtons = document.querySelectorAll('#intro-overlay button');
            introButtons.forEach(button => {
                const handleClick = (e) => {
                    e.preventDefault();
                    const currentPanel = button.closest('.intro-panel');
                    if (!currentPanel || !currentPanel.classList.contains('active')) {
                        console.log("Invalid click - panel not active");
                        return;
                    }
                    
                    const nextAction = button.dataset.next;
                    console.log("Next action:", nextAction);
                    
                    if (nextAction === 'start') {
                        console.log("Starting tutorial from final story panel - Initializing Audio...");
                        // Initialize Audio on user interaction
                        initializeMobileAudio().then(audioStarted => {
                            if (audioStarted && !soundsReady) {
                                console.log("Setting up sounds after intro...");
                                setupSounds();
                            }
                            // Proceed after audio attempt
                            currentPanel.style.opacity = '0';
                            setTimeout(() => {
                                currentPanel.style.display = 'none';
                                currentPanel.classList.remove('active');
                                introOverlay.style.display = 'none';
                                document.getElementById('tutorial-overlay').style.display = 'flex';
                                showTutorialPanel(1);
                            }, 300);
                        });
                    } else {
                        const nextPanelNumber = parseInt(nextAction);
                        if (!isNaN(nextPanelNumber)) {
                            showIntroPanel(nextPanelNumber);
                        }
                    }
                };
    
                // Add both touch and click handlers with debounce
                let isHandling = false;
                const debouncedHandler = (e) => {
                    if (isHandling) {
                        console.log("Ignoring click - already handling");
                        return;
                    }
                    isHandling = true;
                    handleClick(e);
                    setTimeout(() => { isHandling = false; }, 300);
                };
    
                button.addEventListener('touchstart', debouncedHandler, { passive: false });
                button.addEventListener('click', debouncedHandler);
            });

            // Add skip button handler
            const skipButton = document.getElementById('skip-intro-button');
            if (skipButton) {
                const handleSkip = (e) => {
                    e.preventDefault();
                    console.log("Skipping intro and tutorial - Initializing Audio...");
                    // Initialize Audio on user interaction
                    initializeMobileAudio().then(audioStarted => {
                        if (audioStarted && !soundsReady) {
                            console.log("Setting up sounds after skip...");
                            setupSounds();
                        }
                        // Hide intro overlay and start game directly
                        introOverlay.style.display = 'none';
                        introOverlay.style.opacity = '0';
                        startGame();
                    });
                };

                // Simplified event handling for mobile
                skipButton.addEventListener('touchstart', handleSkip, { passive: false });
                skipButton.addEventListener('click', handleSkip);
            }
        }
        // Add mobile audio initialization function
        function initializeMobileAudio() {
            return new Promise((resolve) => {
                if (Tone.context.state !== 'running') {
                    console.log("AudioContext not running, attempting to start...");
                    Tone.start().then(() => {
                        console.log("AudioContext started successfully!");
                        resolve(true);
                    }).catch(e => {
                        console.error("Tone.start() failed:", e);
                        resolve(false); // Resolve false if starting fails
                    });
                } else {
                    console.log("AudioContext already running.");
                    resolve(true); // Resolve true if already running
                }
            });
        }

        function startGame() { 
            console.log("startGame function called"); 
            currentLevel = 1; 
            proceedWithGameStart(); // Directly proceed
        }

        function proceedWithGameStart() {
            console.log("Proceeding with game start...");
            
            // Hide all overlays
            introOverlay.style.display = 'none';
            introOverlay.style.opacity = 0;
            winMessage.style.display = 'none';
            winMessage.style.opacity = 0;
            levelTransitionOverlay.style.display = 'none';
            levelTransitionOverlay.style.opacity = 0;
            gameOverOverlay.style.display = 'none';
            gameOverOverlay.style.opacity = 0;
            
            // Reset game state before setup
            resetGameState(currentLevel - 1);
            
            // Set game state to playing before setup to ensure rivals are active
            gameState = 'playing';
            
            // Show mobile tutorial if on mobile
            if (window.innerWidth <= 768) {
                const mobileTutorial = document.getElementById('mobile-tutorial');
                mobileTutorial.style.display = 'block';
                setTimeout(() => {
                    mobileTutorial.style.opacity = '1';
                    setTimeout(() => {
                        mobileTutorial.style.opacity = '0';
                        setTimeout(() => {
                            mobileTutorial.style.display = 'none';
                        }, 300);
                    }, 1500);
                }, 100);
            }
            
            // Setup the game
            setupGame(currentLevel - 1).then(() => {
                console.log("Game setup complete, starting game loop");
                kccStatusElement.innerHTML = 'ðŸŸ¢<span>LIVE</span>';
                kccStatusElement.classList.add('live');
                lastTimestamp = performance.now(); // Initialize timestamp for delta time
                 if (animationFrameId) cancelAnimationFrame(animationFrameId); gameLoop(); console.log("Game Started - Level", currentLevel); }).catch(err => { console.error("Error during setupGame in proceedWithGameStart:", err); }); }
        function restartGame() { /* ... Unchanged ... */ winMessage.style.display = 'none'; winMessage.style.opacity = 0; gameOverOverlay.style.display = 'none'; gameOverOverlay.style.opacity = 0; startGame(); }
        function resetGameState(levelIndex) { /* ... Unchanged ... */ const levelConf = levelConfigs[levelIndex]; if (!levelConf) return; player.isDashing = false; player.lastDashTime = 0; player.dashParticles = []; player.isFiringLaser = false; player.lastLaserTime = 0; player.isInvulnerable = false; player.lastHitTime = 0; /* tapDashActive removed */ rivals.forEach(rival => { rival.isDestroyed = false; rival.hazardActive = false; rival.isInWarning = false; rival.hazardFeedbackGiven = false; rival.dodgeFeedbackGiven = false; if (rival.hazardElement) { rival.hazardElement.classList.remove('active', 'warning'); rival.hazardElement.style.opacity = 0; if (!rival.hazardElement.parentNode) { gameContainer.appendChild(rival.hazardElement); } } }); approvalMeter.value = 10; feedbackArea.innerHTML = ''; halfwayReached = false; particles.length = 0; collectiblesCollected = 0; isTargetZoneActive = false; if(targetZone.element) targetZone.element.classList.remove('active'); }

        // --- Input Handling --- (Unchanged)
        // Keyboard Handling
        window.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); keys[key] = true; if (["arrowup", "arrowdown", "arrowleft", "arrowright", " ", "e"].includes(key)) { e.preventDefault(); } if (key === 'e' && gameState === 'playing' && !player.isFiringLaser && Date.now() - player.lastLaserTime > player.laserCooldown) { fireLaser(); } });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        // Game area tap handling
        let lastTapTime = 0;
        const doubleTapDelay = 300; // Time window for double tap in milliseconds

        function handleGameAreaTap(event) {
                            event.preventDefault();
                            if (gameState !== 'playing') return;
                            
                            // Check if tap is on laser button or joystick
                            const target = event.target;
                            if (target.id === 'laser-button' ||
                                target.className === 'laser-button-inner' ||
                                target.id === 'joystick-area' ||
                                target.id === 'joystick-base' ||
                                target.id === 'joystick-knob') {
                                return;
                            }
                
                            const currentTime = Date.now();
                            const touch = event.touches[0];
                            const rect = canvas.getBoundingClientRect();
                            const tapX = touch.clientX - rect.left;
                            const tapY = touch.clientY - rect.top;
                            const scaleX = canvas.width / rect.width;
                            const scaleY = canvas.height / rect.height;
                            const gameX = tapX * scaleX;
                            const gameY = tapY * scaleY;
                
                            // Check if tap hits any rival with a larger hit area
                            let rivalHit = false;
                            for (const rival of rivals) {
                                if (!rival.isDestroyed) {
                                    // Add a larger margin around the rival for easier tapping on mobile
                                    const hitMargin = window.innerWidth <= 768 ? 40 : 30;
                                    const rivalCenterX = rival.x + rival.width/2;
                                    const rivalCenterY = rival.y + rival.height/2;
                                    const dx = gameX - rivalCenterX;
                                    const dy = gameY - rivalCenterY;
                                    const distanceSquared = dx * dx + dy * dy;
                                    const hitRadius = rival.width/2 + hitMargin;
                                    
                                    if (distanceSquared <= hitRadius * hitRadius) {
                                        rivalHit = true;
                                        console.log("Rival tapped!");
                                        
                                        // Calculate direction from player to rival
                                        const toRivalX = rivalCenterX - (player.x + player.width/2);
                                        const toRivalY = rivalCenterY - (player.y + player.height/2);
                                        const dist = Math.sqrt(toRivalX * toRivalX + toRivalY * toRivalY);
                                        
                                        // Update player's aim direction
                                        player.lastMoveDx = toRivalX / dist;
                                        player.lastMoveDy = toRivalY / dist;
                                        
                                        // Fire laser if cooldown allows
                                        if (!player.isFiringLaser && currentTime - player.lastLaserTime > player.laserCooldown) {
                                            fireLaser();
                                        }
                                        break;
                                    }
                                }
                            }
                
                            // If no rival was hit, perform dash towards tap location
                            if (!rivalHit && !player.isDashing && currentTime - player.lastDashTime > player.dashCooldown) {
                                // Calculate dash direction from player to tap location
                                const playerCenterX = player.x + player.width/2;
                                const playerCenterY = player.y + player.height/2;
                                const dx = gameX - playerCenterX;
                                const dy = gameY - playerCenterY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist > 0) {  // Prevent division by zero
                                    // Update movement direction for dash
                                    player.lastMoveDx = dx / dist;
                                    player.lastMoveDy = dy / dist;
                                    
                                    console.log("Dashing towards:", {x: gameX, y: gameY});
                                    player.isDashing = true;
                                    player.lastDashTime = currentTime;
                                    triggerFeedback('dash');
                                    
                                    // Create initial dash particles
                                    player.dashParticles.push({
                                        x: playerCenterX,
                                        y: playerCenterY,
                                        life: 20
                                    });
                                    
                                    setTimeout(() => {
                                        player.isDashing = false;
                                    }, player.dashDuration);
                                }
                            }
                        }
        // Joystick Touch Handling
        joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joystickActive = true; joystickArea.classList.add('active'); const touch = e.changedTouches[0]; joystickStartX = touch.clientX; joystickStartY = touch.clientY; }, { passive: false });
        joystickArea.addEventListener('touchmove', (e) => { e.preventDefault(); if (!joystickActive) return; if (!joystickDimensionsCalculated || maxJoystickDist <= 0) return; const touch = e.changedTouches[0]; const currentX = touch.clientX; const currentY = touch.clientY; const areaRect = joystickArea.getBoundingClientRect(); const areaCenterX = areaRect.left + areaRect.width / 2; const areaCenterY = areaRect.top + areaRect.height / 2; let dx = currentX - areaCenterX; let dy = currentY - areaCenterY; const dist = Math.sqrt(dx * dx + dy * dy); const angle = Math.atan2(dy, dx); const clampedDist = Math.min(dist, maxJoystickDist); const knobX = clampedDist * Math.cos(angle); const knobY = clampedDist * Math.sin(angle); joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`; const deadZone = maxJoystickDist * 0.15; if (clampedDist > deadZone) { const magnitude = Math.sqrt(dx * dx + dy * dy); joystickDx = dx / magnitude; joystickDy = dy / magnitude; /* joystickMagnitude removed */ } else { joystickDx = 0; joystickDy = 0; /* joystickMagnitude removed */ } }, { passive: false });
        joystickArea.addEventListener('touchend', (e) => { e.preventDefault(); if (!joystickActive) return; joystickActive = false; joystickArea.classList.remove('active'); joystickKnob.style.transform = `translate(-50%, -50%)`; joystickDx = 0; joystickDy = 0; /* joystickMagnitude removed */ }, { passive: false });

        // --- Laser Firing Logic --- (Unchanged)
        function fireLaser() { 
            if (player.isFiringLaser || Date.now() - player.lastLaserTime < player.laserCooldown) return; 
            player.isFiringLaser = true; 
            player.lastLaserTime = Date.now(); 
            playSound('laserFire'); 
            const laserDx = player.lastMoveDx; 
            const laserDy = player.lastMoveDy; 
            const laserStartX = player.x + player.width / 2 + laserDx * (player.width * 0.4); 
            const laserStartY = player.y + player.height / 2 + laserDy * (player.height * 0.4); 
            const laserEndX = laserStartX + laserDx * player.laserRange; 
            const laserEndY = laserStartY + laserDy * player.laserRange; 
            let rivalHit = false; 

            // Increase laser width for more forgiving hit detection
            const effectiveLaserWidth = player.laserWidth * 2.5; // Increased from base width

            for (const rival of rivals) { 
                if (!rival.isDestroyed && !rivalHit) { 
                    const rivalCenterX = rival.x + rival.width / 2; 
                    const rivalCenterY = rival.y + rival.height / 2; 
                    const rivalRadius = rival.width / 2; 

                    // Calculate distance from rival to laser line
                    const sx = rivalCenterX - laserStartX; 
                    const sy = rivalCenterY - laserStartY; 
                    const segDx = laserEndX - laserStartX; 
                    const segDy = laserEndY - laserStartY; 
                    const segLenSq = segDx * segDx + segDy * segDy; 
                    let t = 0; 
                    if (segLenSq > 0) { 
                        t = (sx * segDx + sy * segDy) / segLenSq; 
                        t = Math.max(0, Math.min(1, t)); 
                    } 
                    const closestX = laserStartX + t * segDx; 
                    const closestY = laserStartY + t * segDy; 
                    const distSq = Math.pow(rivalCenterX - closestX, 2) + Math.pow(rivalCenterY - closestY, 2); 

                    // More forgiving hit detection with increased hit area
                    const hitThreshold = rivalRadius + effectiveLaserWidth / 2;
                    const hitMargin = rivalRadius * 0.5; // Additional margin for near misses

                    if (distSq < (hitThreshold + hitMargin) * (hitThreshold + hitMargin)) { 
                        console.log("Rival Hit!"); 
                        rival.isDestroyed = true; 
                        rivalHit = true; 
                        triggerFeedback('destroy_rival'); 
                        createDisintegrationEffect(rivalCenterX, rivalCenterY); 
                        if (rival.hazardElement && rival.hazardElement.parentNode) { 
                            rival.hazardElement.parentNode.removeChild(rival.hazardElement); 
                        }
                        updateObjectiveText(); // Update enemy count after destroying a rival
                        break; 
                    } 
                } 
            } 
            setTimeout(() => { player.isFiringLaser = false; }, player.laserDuration); 
        }

        // --- Damage Application Function --- (Unchanged)
        function applyDamage(type) {
            if (player.isInvulnerable) return;
            
            // Set invulnerability state
            player.isInvulnerable = true;
            player.lastHitTime = Date.now();
            
            // Add visual feedback class
            const playerElement = document.querySelector('.kovu-svg');
            if (playerElement) {
                playerElement.classList.add('player-invulnerable');
                setTimeout(() => {
                    playerElement.classList.remove('player-invulnerable');
                }, player.invulnerabilityDuration);
            }
            
            // Trigger feedback and sound
            triggerFeedback(type);
            
            // Reset invulnerability after duration
            setTimeout(() => {
                player.isInvulnerable = false;
            }, player.invulnerabilityDuration);
        }

        // --- Game Over Trigger --- (Unchanged)
        function triggerGameOver() { if (gameState === 'gameOver') return; console.log("Game Over triggered!"); gameState = 'gameOver'; if (animationFrameId) cancelAnimationFrame(animationFrameId); playSound('gameOver'); levelTransitionOverlay.style.display = 'none'; levelTransitionOverlay.style.opacity = 0; winMessage.style.display = 'none'; winMessage.style.opacity = 0; gameOverOverlay.style.display = 'flex'; setTimeout(() => { gameOverOverlay.style.opacity = 1; }, 50); kccStatusElement.innerHTML = 'ðŸ”´<span>OFFLINE</span>'; kccStatusElement.classList.remove('live'); }

        // --- Game Logic (Update - Modified Movement Speed) ---
        function update(deltaTime) { // Accept deltaTime
            if (gameState !== 'playing') return;
            const now = Date.now();
            // --- Base speed is now pixels per second ---
            let currentSpeed = player.speed;

            if (player.isInvulnerable && now - player.lastHitTime > player.invulnerabilityDuration) { player.isInvulnerable = false; }

            // --- Movement Logic (Keyboard/Joystick) ---
            let moveX = 0; let moveY = 0;
            let isMoving = false;

            // Prioritize Joystick Input if active
            if (joystickActive && (joystickDx !== 0 || joystickDy !== 0)) {
                 moveX = joystickDx;
                 moveY = joystickDy;
                 // Speed is now constant when joystick is active outside deadzone
                 currentSpeed = player.speed;
                 isMoving = true;
                 player.lastMoveDx = joystickDx;
                 player.lastMoveDy = joystickDy;
            } else {
                // Keyboard Input (Fallback)
                let keyMoveX = 0; let keyMoveY = 0;
                if (keys['arrowup'] || keys['w']) { keyMoveY -= 1; isMoving = true; }
                if (keys['arrowdown'] || keys['s']) { keyMoveY += 1; isMoving = true; }
                if (keys['arrowleft'] || keys['a']) { keyMoveX -= 1; isMoving = true; }
                if (keys['arrowright'] || keys['d']) { keyMoveX += 1; isMoving = true; }

                const keyMagnitude = Math.sqrt(keyMoveX * keyMoveX + keyMoveY * keyMoveY);
                if (keyMagnitude > 0) {
                    moveX = keyMoveX / keyMagnitude;
                    moveY = keyMoveY / keyMagnitude;
                    player.lastMoveDx = moveX;
                    player.lastMoveDy = moveY;
                    currentSpeed = player.speed; // Base speed for keyboard
                } else {
                    moveX = 0; moveY = 0;
                }
            }

            // Apply Keyboard/Joystick Movement (Factoring in Delta Time)
            if (isMoving) {
                 player.x += moveX * currentSpeed * deltaTime;
                 player.y += moveY * currentSpeed * deltaTime;
            }

            // Keyboard/Button Dash Activation & Boost
            if (keys[' '] && !player.isDashing && now - player.lastDashTime > player.dashCooldown) {
                 player.isDashing = true;
                 player.lastDashTime = now;
                 triggerFeedback('dash');
                 setTimeout(() => { player.isDashing = false; }, player.dashDuration);
            }
            if (player.isDashing && isMoving) { // Boost only for keyboard/button dash
                  const boostSpeed = player.speed * 2.0; // Pixels per second boost
                  player.x += moveX * boostSpeed * deltaTime;
                  player.y += moveY * boostSpeed * deltaTime;
                  player.dashParticles.push({ x: player.x + player.width / 2, y: player.y + player.height / 2, life: 20 });
            }


            // Update dash particles & Keep player in bounds (Unchanged)
            player.dashParticles = player.dashParticles.filter(p => p.life > 0); player.dashParticles.forEach(p => p.life--);
            player.x = Math.max(0, Math.min(canvasWidth - player.width, player.x)); player.y = Math.max(0, Math.min(canvasHeight - player.height, player.y));
            particles.forEach((p, index) => { p.x += p.vx * deltaTime * 60; p.y += p.vy * deltaTime * 60; p.life -= deltaTime * 60; if (p.life <= 0) { particles.splice(index, 1); } }); // Update particles based on delta time

            // Update Each Rival & Check Hazard Hits
            rivals.forEach((rival, index) => {
                
                if (rival.isDestroyed) {
                    if (rival.hazardElement && rival.hazardElement.style.opacity !== '0') {
                        rival.hazardElement.style.opacity = '0';
                        rival.hazardElement.classList.remove('active', 'warning');
                    }
                    return;
                }

                // --- Refined Rival Movement (Factoring in Delta Time) ---
                // Ensure rival has valid initial position
                if (typeof rival.x !== 'number' || isNaN(rival.x)) {
                    rival.x = rival.startX;
                }
                
                // Calculate movement for this frame
                const rivalSpeedThisFrame = rival.speed * deltaTime;
                const intendedX = rival.x + (rivalSpeedThisFrame * rival.direction);
                
                // Calculate patrol boundaries
                const patrolLeftBound = Math.max(0, rival.startX - rival.patrolRange);
                const patrolRightBound = Math.min(canvasWidth - rival.width, rival.startX + rival.patrolRange);
                
                // Check if we need to reverse direction
                if ((rival.direction === 1 && intendedX >= patrolRightBound) ||
                    (rival.direction === -1 && intendedX <= patrolLeftBound)) {
                    rival.direction *= -1;
                }
                
                // Update position with bounds checking
                rival.x = Math.max(patrolLeftBound, Math.min(patrolRightBound, intendedX));
                rival.y = Math.max(0, Math.min(canvasHeight - rival.height, rival.y));


                // Hazard Logic (Unchanged)
                if (!rival.isInWarning && !rival.hazardActive && now - rival.lastHazardTime > rival.hazardTimer) { rival.isInWarning = true; rival.lastHazardTime = now; playSound('hazardWarn'); const predictDistance = 50; const randomOffsetRange = 40; const targetBaseX = player.x + player.width / 2 + player.lastMoveDx * predictDistance; const targetBaseY = player.y + player.height / 2 + player.lastMoveDy * predictDistance; rival.hazardTargetX = targetBaseX + (Math.random() - 0.5) * randomOffsetRange; rival.hazardTargetY = targetBaseY + (Math.random() - 0.5) * randomOffsetRange; rival.hazardTargetX = Math.max(rivalHazardRadius, Math.min(canvasWidth - rivalHazardRadius, rival.hazardTargetX)); rival.hazardTargetY = Math.max(rivalHazardRadius, Math.min(canvasHeight - rivalHazardRadius, rival.hazardTargetY)); if (rival.hazardElement) { rival.hazardElement.style.left = `${rival.hazardTargetX - rivalHazardRadius}px`; rival.hazardElement.style.top = `${rival.hazardTargetY - rivalHazardRadius}px`; rival.hazardElement.classList.add('warning'); rival.hazardElement.style.opacity = 0.8; } setTimeout(() => { if (!rival.isInWarning) return; rival.isInWarning = false; rival.hazardActive = true; rival.hazardFeedbackGiven = false; rival.dodgeFeedbackGiven = false; if (rival.hazardElement) { rival.hazardElement.classList.remove('warning'); rival.hazardElement.classList.add('active'); } setTimeout(() => { if (!rival.hazardActive) return; rival.hazardActive = false; rival.lastHazardTime = Date.now(); rival.hazardTimer = rival.hazardCooldown + Math.random() * 1500; if (rival.hazardElement) { rival.hazardElement.classList.remove('active'); rival.hazardElement.style.opacity = 0; } }, rivalHazardActiveDuration); }, rivalHazardWarningDuration); }
                // Hazard Collision Checks (Unchanged)
                if (rival.hazardActive && !player.isInvulnerable) { const dx = (player.x + player.width / 2) - rival.hazardTargetX; const dy = (player.y + player.height / 2) - rival.hazardTargetY; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < rivalHazardRadius + player.width / 2) { applyDamage('hazard_hit'); } }
                if (player.isDashing && rival.hazardActive) { const dx = (player.x + player.width / 2) - rival.hazardTargetX; const dy = (player.y + player.height / 2) - rival.hazardTargetY; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < rivalHazardRadius + player.width * 1.5 && distance > rivalHazardRadius - player.width) { if (!rival.dodgeFeedbackGiven) { triggerFeedback('dodge'); rival.dodgeFeedbackGiven = true; setTimeout(() => { rival.dodgeFeedbackGiven = false; }, 500); } } }

                // Add FUD shooting logic
                if (!rival.lastFudShot || now - rival.lastFudShot > (5000 + Math.random() * 5000)) {
                    shootFud(rival);
                    rival.lastFudShot = now;
                }
            });

            // Check Player Damage from Direct Rival Collision with circular hitboxes
            if (!player.isInvulnerable) {
                rivals.forEach(rival => {
                    if (!rival.isDestroyed) {
                        // Calculate centers
                        const playerCenterX = player.x + player.width / 2;
                        const playerCenterY = player.y + player.height / 2;
                        const rivalCenterX = rival.x + rival.width / 2;
                        const rivalCenterY = rival.y + rival.height / 2;
                        
                        // Calculate distance between centers
                        const dx = playerCenterX - rivalCenterX;
                        const dy = playerCenterY - rivalCenterY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // More forgiving collision radius (70% of combined dimensions)
                        const collisionRadius = (player.width + rival.width) * 0.35;
                        
                        if (distance < collisionRadius) {
                            applyDamage('rival_collision');
                        }
                    }
                });
            }

            // Check halfway point (Unchanged)
            if (!halfwayReached && player.x > canvasWidth / 2) { halfwayReached = true; triggerFeedback('halfway'); }
            // Check Collectible Collision & Target Activation
            for (let i = collectibles.length - 1; i >= 0; i--) { 
                const collectible = collectibles[i]; 
                if (!collectible.collected) { 
                    const dx = (player.x + player.width / 2) - collectible.x; 
                    const dy = (player.y + player.height / 2) - collectible.y; 
                    const distance = Math.sqrt(dx * dx + dy * dy); 
                    if (distance < collectible.radius + player.width / 2) { 
                        collectible.collected = true; 
                        collectiblesCollected++; 
                        triggerFeedback('collect'); 
                        updateObjectiveText(); 
                    } 
                } 
            }

            // Check advancement condition more frequently
            const allEnemiesDestroyed = rivals.every(rival => rival.isDestroyed);
            if (collectiblesCollected >= totalCollectibles && allEnemiesDestroyed && !isTargetZoneActive) {
                isTargetZoneActive = true;
                console.log("All collectibles gathered and enemies destroyed! Target zone active.");
                if(targetZone.element) targetZone.element.classList.add('active');
                updateObjectiveText();
            }

            // Check Level Win Condition (Unchanged)
            if (isTargetZoneActive) {
                const distToTargetX = player.x + player.width / 2 - targetZone.x;
                const distToTargetY = player.y + player.height / 2 - targetZone.y;
                const distanceToTarget = Math.sqrt(distToTargetX * distToTargetX + distToTargetY * distToTargetY);
                
                // Check if all enemies are destroyed
                const allEnemiesDestroyed = rivals.every(rival => rival.isDestroyed);
                
                if (distanceToTarget < targetZone.radius + player.width / 2 && allEnemiesDestroyed) {
                    if (currentLevel < levelConfigs.length) {
                        gameState = 'level_transition';
                        if (animationFrameId) cancelAnimationFrame(animationFrameId);
                        playSound('win', 'C5');
                        levelTransitionOverlay.style.display = 'flex';
                        levelTransitionOverlay.style.opacity = 1;
                        kccStatusElement.innerHTML = 'ðŸ”´<span>OFFLINE</span>';
                        kccStatusElement.classList.remove('live');
                        
                        // Add click/tap handler to level transition overlay
                        const handleLevelTransitionClick = (e) => {
                            e.preventDefault();
                            levelTransitionOverlay.style.display = 'none';
                            levelTransitionOverlay.style.opacity = 0;
                            currentLevel++;
                            resetGameState(currentLevel - 1);
                            setupGame(currentLevel - 1).then(() => {
                                gameState = 'playing';
                                kccStatusElement.innerHTML = 'ðŸŸ¢<span>LIVE</span>';
                                kccStatusElement.classList.add('live');
                                gameLoop();
                            });
                            // Remove the event listener after use
                            levelTransitionOverlay.removeEventListener('touchstart', handleLevelTransitionClick);
                            levelTransitionOverlay.removeEventListener('click', handleLevelTransitionClick);
                        };
                        
                        levelTransitionOverlay.addEventListener('touchstart', handleLevelTransitionClick, { passive: false });
                        levelTransitionOverlay.addEventListener('click', handleLevelTransitionClick);
                    } else {
                        gameState = 'win';
                        triggerFeedback('win');
                        winMessage.style.display = 'flex';
                        winMessage.style.opacity = 1;
                        kccStatusElement.innerHTML = 'ðŸ”´<span>OFFLINE</span>';
                        kccStatusElement.classList.remove('live');
                        if (animationFrameId) cancelAnimationFrame(animationFrameId);
                        console.log("All levels complete!");
                    }
                }
            }

            // Update FUD projectiles
            updateFudProjectiles(deltaTime);
        }

        // --- Rendering ---
        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Draw background image based on level with improved fallback
            let currentBg;
            try {
                if (currentLevel === 1) {
                    currentBg = imageLoadStatus.bg1 ? backgroundImage : null;
                } else if (currentLevel === 2) {
                    currentBg = imageLoadStatus.bg2 ? backgroundImage2 : backgroundImage;
                } else if (currentLevel === 3) {
                    currentBg = imageLoadStatus.bg3 ? backgroundImage3 : backgroundImage2;
                } else if (currentLevel === 4) {
                    currentBg = imageLoadStatus.bg4 ? backgroundImage4 : backgroundImage3;
                } else if (currentLevel === 5) {
                    currentBg = imageLoadStatus.bg5 ? backgroundImage5 : backgroundImage4;
                } else if (currentLevel === 6) {
                    currentBg = imageLoadStatus.bg6 ? backgroundImage6 : backgroundImage5;
                }
                
                // Ensure we have a valid image before drawing
                if (currentBg && currentBg.complete && currentBg.naturalWidth > 0) {
                    ctx.drawImage(currentBg, 0, 0, canvasWidth, canvasHeight);
                } else {
                    console.warn("Background image not ready, using fallback");
                    // Fallback background with level-specific colors
                    if (currentLevel === 3) {
                        ctx.fillStyle = '#1a1a2e'; // Dark blue for memeverse
                    } else if (currentLevel === 5) {
                        ctx.fillStyle = '#2c3e50'; // Darker blue for whitehouse
                    } else if (currentLevel === 6) {
                        ctx.fillStyle = '#2c3e50'; // Darker blue for mars
                    } else {
                        ctx.fillStyle = '#1a1a2e'; // Default dark blue
                    }
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                }
            } catch (error) {
                console.error("Error drawing background:", error);
                // Fallback background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }
            
            // Background elements & grid with increased opacity for visibility
            ctx.fillStyle = 'rgba(74, 74, 138, 0.25)';
            ctx.fillRect(canvasWidth * 0.1, canvasHeight * 0.1, canvasWidth * 0.2, canvasHeight * 0.15);
            ctx.fillRect(canvasWidth * 0.7, canvasHeight * 0.6, canvasWidth * 0.15, canvasHeight * 0.2);
            ctx.strokeStyle = 'rgba(74, 74, 138, 0.35)';
            ctx.strokeRect(canvasWidth * 0.5, canvasHeight * 0.2, canvasWidth * 0.25, canvasHeight * 0.3);
            ctx.strokeStyle = 'rgba(74, 74, 138, 0.35)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvasWidth; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
                ctx.stroke();
            }
            for (let y = 0; y < canvasHeight; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
                ctx.stroke();
            }
            // Collectibles (Animated Coins)
            collectibles.forEach(collectible => { 
                if (!collectible.collected) { 
                    // Update animation properties
                    collectible.rotation += collectible.rotationSpeed;
                    collectible.bobOffset += collectible.bobSpeed;
                    
                    // Calculate bobbing effect
                    const bobAmount = 2;
                    const bobY = Math.sin(collectible.bobOffset) * bobAmount;
                    
                    // Draw coin
                    ctx.save();
                    ctx.translate(collectible.x, collectible.y + bobY);
                    ctx.rotate(collectible.rotation);
                    
                    // Draw coin body
                    ctx.beginPath();
                    ctx.arc(0, 0, collectible.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFD700'; // Gold color
                    ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    
                    // Draw coin edge
                    ctx.beginPath();
                    ctx.arc(0, 0, collectible.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = '#DAA520'; // Darker gold for edge
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw coin details
                    ctx.beginPath();
                    ctx.arc(0, 0, collectible.radius * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = '#DAA520';
                    ctx.fill();
                    
                    ctx.restore();
                } 
            });
            // Draw scope sight
            const scopeLength = 80; // Length of the scope line (increased from 40)
            const scopeOffset = 10; // Distance from player center
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            
            // Calculate scope start and end points
            const scopeStartX = playerCenterX + player.lastMoveDx * scopeOffset;
            const scopeStartY = playerCenterY + player.lastMoveDy * scopeOffset;
            const scopeEndX = playerCenterX + player.lastMoveDx * (scopeOffset + scopeLength);
            const scopeEndY = playerCenterY + player.lastMoveDy * (scopeOffset + scopeLength);
            
            // Draw the scope line
            ctx.beginPath();
            ctx.moveTo(scopeStartX, scopeStartY);
            ctx.lineTo(scopeEndX, scopeEndY);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw a small dot at the end
            ctx.beginPath();
            ctx.arc(scopeEndX, scopeEndY, 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.fill();

            // Player
            ctx.save();
            try {
                if (player.isInvulnerable) {
                    ctx.globalAlpha = (Math.floor(Date.now() / 100) % 2 === 0) ? 1.0 : 0.5;
                }
                
                // Check if image exists and is valid
                if (player.img) {
                    // Check if image is loaded and has dimensions
                    if (player.img.complete && player.img.naturalWidth > 0) {
                        ctx.drawImage(player.img, player.x, player.y, player.width, player.height);
                    } else {
                        console.warn("Player image not fully loaded, using fallback");
                        // Fallback rendering
                        ctx.fillStyle = '#4a90e2';
                        ctx.fillRect(player.x, player.y, player.width, player.height);
                        ctx.strokeStyle = '#2980b9';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(player.x, player.y, player.width, player.height);
                        
                        // Attempt to reload if needed
                        if (!player.img.complete || player.img.naturalWidth === 0) {
                            console.log("Attempting to reload player image...");
                            player.loadImage().catch(err => {
                                console.error("Failed to reload player image:", err);
                            });
                        }
                    }
                } else {
                    console.warn("Player image is null, using fallback");
                    // Fallback rendering
                    ctx.fillStyle = '#4a90e2';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.strokeStyle = '#2980b9';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(player.x, player.y, player.width, player.height);
                    
                    // Attempt to load image
                    console.log("Attempting to load player image...");
                    player.loadImage().catch(err => {
                        console.error("Failed to load player image:", err);
                    });
                }
            } catch (error) {
                console.error('Error rendering player:', error);
                // Emergency fallback
                ctx.fillStyle = '#4a90e2';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 2;
                ctx.strokeRect(player.x, player.y, player.width, player.height);
            }
            ctx.restore();
            // Optimized dash trail
            if (player.dashParticles.length > 0) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                player.dashParticles.forEach(p => {
                    ctx.globalAlpha = p.life / 20;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, player.width * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();
            }
            // Laser Beam (Unchanged)
            if (player.isFiringLaser) { const laserDx = player.lastMoveDx; const laserDy = player.lastMoveDy; const eyeOffsetX = player.width * 0.22; const eyeOffsetY = -player.height * 0.05; const laserStartX = player.x + player.width / 2 + eyeOffsetX * (laserDx > 0 ? 1 : (laserDx < 0 ? -1 : 1)); const laserStartY = player.y + player.height / 2 + eyeOffsetY; const laserEndX = laserStartX + laserDx * player.laserRange; const laserEndY = laserStartY + laserDy * player.laserRange; ctx.beginPath(); ctx.moveTo(laserStartX, laserStartY); ctx.lineTo(laserEndX, laserEndY); ctx.strokeStyle = 'red'; ctx.lineWidth = player.laserWidth; ctx.shadowColor = 'rgba(255, 0, 0, 0.8)'; ctx.shadowBlur = 10; ctx.stroke(); ctx.beginPath(); ctx.moveTo(laserStartX, laserStartY); ctx.lineTo(laserEndX, laserEndY); ctx.strokeStyle = 'white'; ctx.lineWidth = player.laserWidth * 0.4; ctx.shadowBlur = 0; ctx.stroke(); ctx.shadowColor = 'transparent'; }

            // Rivals
            rivals.forEach(rival => {
                if (!rival.isDestroyed) {
                    try {
                        if (rival.img && !rival.img.loadError) {
                            // Check if image is actually loaded
                            if (rival.img.complete && rival.img.naturalWidth !== 0) {
                                // Draw rival image
                                ctx.drawImage(rival.img, rival.x, rival.y, rival.width, rival.height);
                            } else {
                                // Fallback while image is loading or if load failed
                                ctx.fillStyle = '#f1c40f';
                                ctx.fillRect(rival.x, rival.y, rival.width, rival.height);
                                // Add border for visibility
                                ctx.strokeStyle = '#e67e22';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(rival.x, rival.y, rival.width, rival.height);
                            }
                        } else {
                            // Fallback for missing or error images
                            ctx.fillStyle = '#f1c40f';
                            ctx.fillRect(rival.x, rival.y, rival.width, rival.height);
                            // Add border for visibility
                            ctx.strokeStyle = '#e67e22';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(rival.x, rival.y, rival.width, rival.height);
                        }
                    } catch (error) {
                        console.error('Error rendering rival:', error);
                        // Emergency fallback
                        ctx.fillStyle = '#f1c40f';
                        ctx.fillRect(rival.x, rival.y, rival.width, rival.height);
                    }
                }
            });

            // Optimized particle rendering
            if (particles.length > 0) {
                ctx.save();
                particles.forEach(function(p) {
                    const lifeRatio = Math.max(0, p.life / p.initialLife);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * lifeRatio, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                });
                ctx.restore();
            }

            // Draw FUD projectiles
            drawFudProjectiles();
        }

        // --- Community Feedback --- (Unchanged)
        function triggerFeedback(eventType) { const messageData = feedbackMessages.find(m => m.trigger === eventType); if (!messageData) return; const currentApproval = parseInt(approvalMeter.value); const newApproval = Math.max(0, currentApproval + messageData.approval); approvalMeter.value = newApproval; const msgElement = document.createElement('div'); msgElement.className = 'feedback-message'; if (messageData.negative) { msgElement.classList.add('negative'); } msgElement.textContent = messageData.text; feedbackArea.appendChild(msgElement); while (feedbackArea.children.length > 5) { feedbackArea.removeChild(feedbackArea.firstChild); } setTimeout(() => { msgElement.classList.add('fade-out'); msgElement.addEventListener('transitionend', () => { if (msgElement.parentElement === feedbackArea) { feedbackArea.removeChild(msgElement); } }, { once: true }); }, 2000); if (messageData.sound) { playSound(messageData.sound, messageData.note || null, '8n'); } if (newApproval <= 0 && gameState !== 'gameOver') { triggerGameOver(); } }

        // --- Game Loop (Delta Time Implementation) ---
        function gameLoop(timestamp) { // Receive timestamp
            if (!lastTimestamp) {
                lastTimestamp = timestamp; // Initialize on first frame
            }
            // Calculate delta time, ensuring it's not excessively large (e.g., if tab was inactive)
            const deltaTime = Math.min((timestamp - lastTimestamp) / 1000, 0.1); // Max delta 100ms (10fps)
            lastTimestamp = timestamp;

            // Ensure joystick dimensions are calculated
            if (gameState === 'playing' && !joystickDimensionsCalculated && joystickArea.offsetWidth > 0) {
                joystickRadius = joystickArea.offsetWidth / 2;
                knobRadius = joystickKnob.offsetWidth / 2;
                maxJoystickDist = joystickRadius - knobRadius;
                if (maxJoystickDist > 0) {
                    joystickDimensionsCalculated = true;
                    console.log("Joystick dimensions calculated:", joystickRadius, maxJoystickDist);
                } else {
                     console.warn("Could not calculate valid joystick dimensions yet.");
                }
            }

            // Update laser button cooldown state
            if (gameState === 'playing') {
                const laserButton = document.getElementById('laser-button');
                if (laserButton) {
                    const now = Date.now();
                    const isOnCooldown = now - player.lastLaserTime < player.laserCooldown;
                    laserButton.classList.toggle('cooldown', isOnCooldown);
                }
            }

            if (gameState === 'playing') {
                update(deltaTime); // Pass deltaTime to update
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                console.log("Game loop paused - state:", gameState);
                // Reset timestamp when paused so delta isn't huge on resume
                lastTimestamp = 0;
            }
        }

        // --- Initial Setup Call ---
        window.onload = async () => {
             console.log("Window loaded.");
             gameState = 'intro';
             
             // Show loading state
             introOverlay.style.display = 'flex';
             introOverlay.style.opacity = '1';
             document.getElementById('tutorial-overlay').style.display = 'none';
             
             try {
                 // Preload all images before setup
                 await preloadGameImages();
                 console.log("Images preloaded successfully");
                 
                 // Initialize game setup after images are loaded
                 await setupGame(currentLevel - 1);
                 console.log("Initial game setup complete");
             } catch (error) {
                 console.error("Error during game initialization:", error);
             }
             
             // Setup intro and tutorial handlers
             setupIntroTouchHandlers();
             setupTutorialHandlers();
             console.log("Intro and tutorial handlers added.");
             
             // Add touch listeners after DOM is loaded
             joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joystickActive = true; joystickArea.classList.add('active'); const touch = e.changedTouches[0]; joystickStartX = touch.clientX; joystickStartY = touch.clientY; }, { passive: false });
             joystickArea.addEventListener('touchmove', (e) => { e.preventDefault(); if (!joystickActive) return; if (!joystickDimensionsCalculated || maxJoystickDist <= 0) return; const touch = e.changedTouches[0]; const currentX = touch.clientX; const currentY = touch.clientY; const areaRect = joystickArea.getBoundingClientRect(); const areaCenterX = areaRect.left + areaRect.width / 2; const areaCenterY = areaRect.top + areaRect.height / 2; let dx = currentX - areaCenterX; let dy = currentY - areaCenterY; const dist = Math.sqrt(dx * dx + dy * dy); const angle = Math.atan2(dy, dx); const clampedDist = Math.min(dist, maxJoystickDist); const knobX = clampedDist * Math.cos(angle); const knobY = clampedDist * Math.sin(angle); joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`; const deadZone = maxJoystickDist * 0.15; if (clampedDist > deadZone) { const magnitude = Math.sqrt(dx * dx + dy * dy); joystickDx = dx / magnitude; joystickDy = dy / magnitude; /* joystickMagnitude removed */ } else { joystickDx = 0; joystickDy = 0; /* joystickMagnitude removed */ } }, { passive: false });
             joystickArea.addEventListener('touchend', (e) => { e.preventDefault(); if (!joystickActive) return; joystickActive = false; joystickArea.classList.remove('active'); joystickKnob.style.transform = `translate(-50%, -50%)`; joystickDx = 0; joystickDy = 0; /* joystickMagnitude removed */ }, { passive: false });
             // Add game area tap handler
             gameContainer.addEventListener('touchstart', handleGameAreaTap, { passive: false });
             console.log("Game area tap handler added.");
             
             // Add laser button handler
             const laserButton = document.getElementById('laser-button');
             laserButton.addEventListener('touchstart', (e) => {
                 e.preventDefault();
                 if (gameState === 'playing' && !player.isFiringLaser && Date.now() - player.lastLaserTime > player.laserCooldown) {
                     fireLaser();
                 }
             }, { passive: false });
             console.log("Laser button handler added.");
             
             // Setup intro touch handlers
             setupIntroTouchHandlers();
             console.log("Intro touch handlers added.");

             // Add restart button handler with both touch and click support
             const restartButton = document.getElementById('restart-button');
             if (restartButton) {
                 const handleRestart = (e) => {
                     e.preventDefault();
                     startGame();
                 };
                 
                 restartButton.addEventListener('touchstart', handleRestart, { passive: false });
                 restartButton.addEventListener('click', handleRestart);
                 console.log("Restart button handlers added.");
             }

             // Add play again button handler
             const playAgainButton = document.getElementById('play-again-button');
             if (playAgainButton) {
                 const handlePlayAgain = (e) => {
                     e.preventDefault();
                     restartGame();
                 };
                 
                 playAgainButton.addEventListener('touchstart', handlePlayAgain, { passive: false });
                 playAgainButton.addEventListener('click', handlePlayAgain);
                 console.log("Play again button handlers added.");
             }
        };

        function showTutorialPanel(panelNumber) {
            console.log("Transitioning to tutorial panel:", panelNumber);
            
            const tutorialOverlay = document.getElementById('tutorial-overlay');
            const currentPanel = document.querySelector('.tutorial-panel.active');
            const nextPanel = document.querySelector(`.tutorial-panel[data-panel="${panelNumber}"]`);
            
            if (!nextPanel) {
                console.error("Could not find tutorial panel:", panelNumber);
                return;
            }
            
            // Ensure tutorial overlay is visible
            tutorialOverlay.style.display = 'flex';
            
            if (currentPanel) {
                currentPanel.style.opacity = '0';
                setTimeout(() => {
                    currentPanel.style.display = 'none';
                    currentPanel.classList.remove('active');
                    
                    nextPanel.style.display = 'block';
                    nextPanel.offsetHeight;
                    nextPanel.classList.add('active');
                    nextPanel.style.opacity = '1';
                    console.log("Tutorial panel transition complete:", nextPanel.dataset.panel);
                }, 300);
            } else {
                // If no current panel, just show the next one
                nextPanel.style.display = 'block';
                nextPanel.classList.add('active');
                nextPanel.style.opacity = '1';
                console.log("Initial tutorial panel shown:", nextPanel.dataset.panel);
            }
        }

        function setupTutorialHandlers() {
            const tutorialButtons = document.querySelectorAll('#tutorial-overlay button');
            tutorialButtons.forEach(button => {
                const handleClick = (e) => {
                    e.preventDefault();
                    const currentPanel = button.closest('.tutorial-panel');
                    if (!currentPanel || !currentPanel.classList.contains('active')) {
                        console.log("Invalid click - tutorial panel not active");
                        return;
                    }
                    
                    const nextAction = button.dataset.next;
                    console.log("Tutorial next action:", nextAction);
                    
                    if (nextAction === 'start') {
                        console.log("Starting game from tutorial - Initializing Audio...");
                        // Initialize Audio on user interaction
                        initializeMobileAudio().then(audioStarted => {
                            if (audioStarted && !soundsReady) {
                                console.log("Setting up sounds after tutorial...");
                                setupSounds();
                            }
                            // Proceed after audio attempt
                            currentPanel.style.opacity = '0';
                            setTimeout(() => {
                                currentPanel.style.display = 'none';
                                currentPanel.classList.remove('active');
                                tutorialActive = false;
                                document.getElementById('tutorial-overlay').style.display = 'none';
                                startGame(); // Start the game
                            }, 300);
                        });
                    } else {
                        const nextPanelNumber = parseInt(nextAction);
                        if (!isNaN(nextPanelNumber)) {
                            showTutorialPanel(nextPanelNumber);
                        }
                    }
                };
                
                let isHandling = false;
                const debouncedHandler = (e) => {
                    if (isHandling) return;
                    isHandling = true;
                    handleClick(e);
                    setTimeout(() => { isHandling = false; }, 300);
                };
                
                button.addEventListener('touchstart', debouncedHandler, { passive: false });
                button.addEventListener('click', debouncedHandler);
            });
        }

        // Add FUD projectile rendering function
        function drawFudProjectiles() {
            ctx.save();
            fudProjectiles.forEach(projectile => {
                // Draw FUD text
                ctx.font = 'bold 12px "Press Start 2P"';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('FUD', projectile.x, projectile.y);
                
                // Add glow effect
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText('FUD', projectile.x, projectile.y);
                ctx.shadowBlur = 0;
            });
            ctx.restore();
        }

        // Add FUD projectile update function
        function updateFudProjectiles(deltaTime) {
            for (let i = fudProjectiles.length - 1; i >= 0; i--) {
                const projectile = fudProjectiles[i];
                
                // Update position
                projectile.x += projectile.vx * deltaTime;
                projectile.y += projectile.vy * deltaTime;
                
                // Check if projectile is out of bounds
                if (projectile.x < 0 || projectile.x > canvasWidth || 
                    projectile.y < 0 || projectile.y > canvasHeight) {
                    fudProjectiles.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (!player.isInvulnerable) {
                    const dx = (player.x + player.width / 2) - projectile.x;
                    const dy = (player.y + player.height / 2) - projectile.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.width / 2 + fudProjectileSize / 2) {
                        // Apply damage
                        const currentApproval = parseInt(approvalMeter.value);
                        const newApproval = Math.max(0, currentApproval - fudProjectileDamage);
                        approvalMeter.value = newApproval;
                        
                        // Trigger feedback
                        triggerFeedback('fud_hit');
                        
                        // Remove projectile
                        fudProjectiles.splice(i, 1);
                        
                        // Check for game over
                        if (newApproval <= 0 && gameState !== 'gameOver') {
                            triggerGameOver();
                        }
                    }
                }
            }
        }

        // Add FUD shooting function
        function shootFud(rival) {
            if (rival.isDestroyed) return;
            
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const rivalCenterX = rival.x + rival.width / 2;
            const rivalCenterY = rival.y + rival.height / 2;
            
            // Calculate direction to player
            const dx = playerCenterX - rivalCenterX;
            const dy = playerCenterY - rivalCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Normalize direction
            const vx = (dx / distance) * fudProjectileSpeed;
            const vy = (dy / distance) * fudProjectileSpeed;
            
            // Create projectile
            fudProjectiles.push({
                x: rivalCenterX,
                y: rivalCenterY,
                vx: vx,
                vy: vy
            });
            
            // Play sound
            playSound('laserFire');
        }

    </script>

</body>
</html>
