<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kovu: #CommunityRescue Arena MVP</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Base styles */
        html, body {
            height: 100%; /* Full height */
            width: 100%; /* Full width */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent default touch behaviors */
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a2e;
            color: #e0e0e0;
            display: flex; /* Use flexbox for overall layout */
            justify-content: center;
            align-items: center;
            -webkit-user-select: none; -ms-user-select: none; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px; /* Max width on desktop */
            height: 100%; /* Take full available height */
            padding: 5px;
            box-sizing: border-box;
        }
        #game-container {
            border: 4px solid #4a4a8a;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(74, 74, 138, 0.7);
            position: relative; /* Needed for absolute children */
            width: 100%;
            flex-grow: 1; /* Takes up available vertical space */
            min-height: 200px;
            background: linear-gradient(135deg, #16213e, #0f3460);
            overflow: hidden; /* Clip canvas/elements */
        }
        #gameCanvas { display: block; width: 100%; height: 100%; border-radius: 10px; }
        /* Overlays */
        #intro-overlay, #level-transition-overlay, #win-message, #game-over-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 100; padding: 20px; border-radius: 10px; transition: opacity 0.5s ease; box-sizing: border-box; }
        #intro-overlay { display: flex; opacity: 1; }
        #level-transition-overlay, #win-message, #game-over-overlay { display: none; opacity: 0; }
        .intro-panel { display: none; width: 80%; max-width: 500px; }
        .intro-panel.active { display: block; }
        .intro-panel img { max-width: 100%; height: auto; max-height: 150px; margin-bottom: 10px; border: 2px solid #4a4a8a; border-radius: 8px; }
        .intro-panel p { font-size: 0.7rem; line-height: 1.4; margin-bottom: 15px; }
        /* Buttons */
        button { font-family: 'Press Start 2P', cursive; background: linear-gradient(45deg, #f95738, #ff8c42); color: white; border: none; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-size: 0.8rem; text-transform: uppercase; transition: transform 0.2s ease, box-shadow 0.2s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); margin-top: 8px; }
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 10px rgba(249, 87, 56, 0.5); }
        button:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
        /* UI */
        #ui-container { position: absolute; top: 5px; left: 5px; right: 5px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 50; font-size: 0.6rem; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
        #ui-left, #ui-right { display: flex; flex-direction: column; gap: 4px; }
        #ui-right { align-items: flex-end; }
        #kcc-status, #level-indicator, #approval-meter-container, #objective-display { background-color: rgba(0, 0, 0, 0.5); padding: 4px 8px; border-radius: 5px; pointer-events: auto; }
        #kcc-status { border: 1px solid rgba(255, 0, 0, 0.5); }
        #kcc-status.live { background-color: rgba(0, 255, 0, 0.7); border-color: rgba(0, 255, 0, 0.5); }
        #kcc-status span { margin-left: 4px; }
        #objective-display { text-align: right; max-width: 150px; white-space: normal; }
        #approval-meter-container { width: 120px; font-size: 0.5rem; padding: 4px; }
        #approval-meter { width: 100%; height: 12px; -webkit-appearance: none; appearance: none; border: 1px solid #4a4a8a; border-radius: 3px; overflow: hidden; }
        #approval-meter::-webkit-progress-bar { background-color: #333; border-radius: 3px; }
        #approval-meter::-webkit-progress-value { background: linear-gradient(90deg, #1e90ff, #00ffff); border-radius: 0px; transition: width 0.3s ease; }
        #approval-meter::-moz-progress-bar { background: linear-gradient(90deg, #1e90ff, #00ffff); border-radius: 3px; transition: width 0.3s ease; }
        #feedback-area { position: absolute; bottom: 5px; right: 5px; display: flex; flex-direction: column; align-items: flex-end; pointer-events: none; z-index: 50; max-height: 60px; overflow: hidden; }
        .feedback-message { background-color: rgba(74, 74, 138, 0.8); color: white; padding: 3px 6px; border-radius: 4px; margin-top: 4px; font-size: 0.5rem; opacity: 1; transition: opacity 1s ease-out, transform 0.5s ease-out; transform: translateX(0); }
        .feedback-message.negative { background-color: rgba(200, 0, 0, 0.8); }
        .feedback-message.fade-out { opacity: 0; transform: translateX(20px); }
        #level-transition-overlay h2, #win-message h2, #game-over-overlay h2 { font-size: 1.2rem; margin-bottom: 10px; }
        #level-transition-overlay p, #win-message p, #game-over-overlay p { font-size: 0.8rem; margin-bottom: 15px; }

        /* Player Invulnerability Flash */
        .player-invulnerable { animation: flash-invulnerable 0.2s infinite alternate; }
        @keyframes flash-invulnerable { from { opacity: 1; } to { opacity: 0.5; } }

        /* Target Zone Styling */
        .target-zone { position: absolute; border: 3px dashed #00ff00; border-radius: 50%; box-shadow: 0 0 15px rgba(0, 255, 0, 0.6); opacity: 0; pointer-events: none; transition: opacity 0.5s ease; z-index: 5; }
        .target-zone.active { opacity: 1; pointer-events: auto; }

        /* Hazard Styling (Unchanged) */
        .dogen-hazard { position: absolute; border-radius: 50%; background-color: transparent; pointer-events: none; z-index: 5; opacity: 0; transform: scale(0.9); border: 3px solid transparent; box-shadow: 0 0 0px transparent; transition: opacity 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease, border-color 0.2s ease, background-color 0.2s ease; }
        .dogen-hazard.warning { opacity: 0.8; border-color: #ffd700; transform: scale(0.95); animation: pulse-warning 0.7s infinite alternate; }
        .dogen-hazard.active { opacity: 1; border-style: dashed; border-color: #ff6347; background-color: rgba(255, 99, 71, 0.25); box-shadow: 0 0 25px rgba(255, 99, 71, 0.7); transform: scale(1); animation: none; }
        @keyframes pulse-warning { from { box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); } to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); } }

        /* Styles for Collectibles & Dash Trail (Applied via Canvas) */
        .collectible {}
        .dash-particle {}
        .laser-beam {}
        .disintegration-particle {}

        /* --- Touch Controls --- */
        /* Default (Desktop) - Controls hidden */
        #touch-controls-container { display: none; }

        /* --- Mobile Overrides --- */
        /* Simplified media query for general mobile */
        /* Laser Button Styles */
        #laser-button {
            width: 90px; /* Slightly smaller than joystick */
            height: 90px;
            position: relative;
            pointer-events: auto;
            border-radius: 50%;
            background: none;
            margin-right: 10px;
        }
        .laser-button-inner {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(255, 50, 50, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.4);
            transition: all 0.2s ease;
        }
        #laser-button .laser-button-inner {
            background-color: rgba(255, 50, 50, 0.7);
            border-color: rgba(255, 255, 255, 0.8);
            transition: all 0.2s ease;
        }
        
        #laser-button.cooldown .laser-button-inner {
            background-color: rgba(255, 50, 50, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        #laser-button:active .laser-button-inner {
            background-color: rgba(255, 100, 100, 0.7);
            border-color: rgba(255, 255, 255, 0.8);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            #game-wrapper {
                 max-height: none; /* Allow full height */
                 padding: 0; /* Remove padding */
            }
            #game-container {
                 border: none; /* Remove border */
                 border-radius: 0; /* Remove rounding */
                 box-shadow: none; /* Remove shadow */
            }
            #gameCanvas {
                 border-radius: 0; /* Remove rounding */
            }

            #touch-controls-container {
                display: flex; /* Show controls on mobile */
                position: absolute; /* Overlay on game container */
                bottom: 0; left: 0; right: 0;
                height: auto; /* Let content determine height */
                padding: 15px; /* Padding around controls */
                z-index: 60; /* Above canvas, below overlays */
                pointer-events: none; /* Container doesn't block */
                background: none;
                justify-content: space-between;
                align-items: flex-end; /* Align controls to bottom */
            }
            /* Joystick Styles */
            #joystick-area {
                width: 130px; /* Slightly larger */
                height: 130px;
                position: relative; pointer-events: auto; border-radius: 50%; background: none;
            }
            #joystick-base { position: absolute; width: 100%; height: 100%; border-radius: 50%; background-color: rgba(80, 80, 80, 0.4); border: 2px solid rgba(255, 255, 255, 0.4); top: 0; left: 0; }
            #joystick-knob { position: absolute; width: 60px; /* Slightly larger */ height: 60px; background-color: rgba(200, 200, 200, 0.6); border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: background-color 0.1s ease; }
            #joystick-area.active #joystick-knob { background-color: rgba(255, 255, 255, 0.7); }

            /* Game area tap handling */
            #game-container {
                touch-action: none; /* Prevent default touch behaviors */
            }

            #controls-hint { display: none; }
        }

    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-container">
            <div id="intro-overlay">
                 <div class="intro-panel active" id="intro-1" data-panel="1">
                     <img src="https://placehold.co/400x200/333333/cccccc?text=Abandoned+Kovu" alt="Abandoned Kovu" onerror="this.src='https://placehold.co/400x200/333333/cccccc?text=Image+Error'">
                     <p>Abandoned... like a delisted coin. Colors faded, feeling worthless...</p>
                     <button data-next="2">Next</button>
                 </div>
                 <div class="intro-panel" id="intro-2" data-panel="2">
                     <img src="https://placehold.co/400x200/555555/dddddd?text=KCC+Rescue" alt="KCC Rescue" onerror="this.src='https://placehold.co/400x200/555555/dddddd?text=Image+Error'">
                     <p>"Subject Kovu located. Vital signs critical. Initiating community rescue protocol." The KCC found me.</p>
                     <button data-next="3">Next</button>
                 </div>
                 <div class="intro-panel" id="intro-3" data-panel="3">
                     <img src="https://placehold.co/400x200/1a1a2e/00ffff?text=Upgrade+Bay" alt="Upgrade Bay" onerror="this.src='https://placehold.co/400x200/1a1a2e/00ffff?text=Image+Error'">
                     <p>"The Community pooled resources... gave you upgrades! This 'Community Link' keeps us connected. Think of it as your personal live feed!"</p>
                     <button data-next="4">Next</button>
                 </div>
                 <div class="intro-panel" id="intro-4" data-panel="4">
                     <img src="https://placehold.co/400x200/0f3460/ffffff?text=Entering+Arena" alt="Entering Arena" onerror="this.src='https://placehold.co/400x200/0f3460/ffffff?text=Image+Error'">
                     <p>"Go out there, engage, climb the ranks! We'll be watching. Make us proud!" ... A second chance?</p>
                     <button data-next="start">Enter the Arena!</button>
                 </div>
            </div>
            <div id="level-transition-overlay"><h2>Level Complete!</h2><p>Prepare for the next challenge...</p></div>
            <div id="game-over-overlay"><h2>Game Over!</h2><p>Community approval dropped too low. Try again?</p><button onclick="startGame()">Restart</button></div>
            <canvas id="gameCanvas"></canvas>
            <div id="ui-container">
                 <div id="ui-left"> <div id="kcc-status">ðŸ”´<span>OFFLINE</span></div>
                      <div id="level-indicator">Level: 1</div>
                 </div>
                 <div id="ui-right"> <div id="approval-meter-container"> Community Approval: <progress id="approval-meter" value="10" max="100"></progress> </div>
                      <div id="objective-display">Objective: Collect Data! (0/0)</div>
                 </div>
            </div>
            <div id="feedback-area"></div>
            <div id="win-message"> <h2>All Levels Complete!</h2> <p>#KovuWins! The Community is ecstatic!</p> <button onclick="restartGame()">Play Again?</button> </div>

             <div id="touch-controls-container">
                  <div id="joystick-area">
                      <div id="joystick-base"></div>
                      <div id="joystick-knob"></div>
                  </div>
                  <div id="laser-button">
                      <div class="laser-button-inner"></div>
                  </div>
              </div>
        </div>
        <div id="controls-hint">Controls: Arrow Keys/WASD/Joystick, Space/Touch to Dash, E/Touch to Fire Laser</div>
    </div>


    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const introOverlay = document.getElementById('intro-overlay');
        const winMessage = document.getElementById('win-message');
        const levelTransitionOverlay = document.getElementById('level-transition-overlay');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const kccStatusElement = document.getElementById('kcc-status');
        const objectiveDisplay = document.getElementById('objective-display');
        const approvalMeter = document.getElementById('approval-meter');
        const feedbackArea = document.getElementById('feedback-area');
        const levelIndicator = document.getElementById('level-indicator');
        // Joystick Elements
        const joystickArea = document.getElementById('joystick-area');
        const joystickKnob = document.getElementById('joystick-knob');
        let canvasWidth, canvasHeight;
        let gameState = 'intro';
        let keys = {};
        let animationFrameId;
        let currentLevel = 1;
        let collectiblesCollected = 0;
        let totalCollectibles = 0;
        let isTargetZoneActive = false;

        // Joystick state variables
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickRadius = 0;
        let knobRadius = 0;
        let maxJoystickDist = 0;
        let joystickDx = 0;
        let joystickDy = 0;
        // let joystickMagnitude = 0; // No longer used for speed scaling
        let joystickDimensionsCalculated = false;

        // Delta Time variables
        let lastTimestamp = 0;

        // --- Level Configuration --- (Unchanged)
        const levelConfigs = [ { level: 1, numRivals: 3, numCollectibles: 5, targetXRatio: 0.85, targetYRatio: 0.8, objectiveText: "Objective: Reach the Viral Stage!", rivalSpeedMultiplier: 1.0, rivalHazardCooldownBase: 3500 }, { level: 2, numRivals: 4, numCollectibles: 7, targetXRatio: 0.15, targetYRatio: 0.2, objectiveText: "Objective: Reach the Upload Point!", rivalSpeedMultiplier: 1.1, rivalHazardCooldownBase: 3000 }, { level: 3, numRivals: 5, numCollectibles: 8, targetXRatio: 0.5, targetYRatio: 0.15, objectiveText: "Objective: Secure the Data Core!", rivalSpeedMultiplier: 1.15, rivalHazardCooldownBase: 2800 }, { level: 4, numRivals: 6, numCollectibles: 10, targetXRatio: 0.8, targetYRatio: 0.2, objectiveText: "Objective: Final Broadcast Point!", rivalSpeedMultiplier: 1.2, rivalHazardCooldownBase: 2500 } ];

        // --- Sound Effects Setup --- (Unchanged)
        let soundsReady = false; let synths = {};
        function setupSounds() { try { synths.dash = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); synths.collect = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination(); synths.win = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.3, release: 0.5 } }).toDestination(); synths.feedbackPositive = new Tone.PluckSynth().toDestination(); synths.feedbackNegative = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); synths.hazardWarn = new Tone.Synth({ oscillator: { type: 'pulse', width: 0.3 }, envelope: { attack: 0.01, decay: 0.05, sustain: 0.1, release: 0.1 } }).toDestination(); synths.laserFire = new Tone.Synth({ oscillator: { type: 'pwm', modulationFrequency: 0.2 }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination(); synths.rivalDestroyed = new Tone.MetalSynth({ frequency: 100, envelope: { attack: 0.01, decay: 0.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(); synths.playerHit = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination(); synths.gameOver = new Tone.Synth({ oscillator: { type: 'fatsawtooth', count: 3, spread: 30 }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.1, release: 0.8 } }).toDestination(); soundsReady = true; console.log("Tone.js Synths Initialized"); } catch (error) { console.error("Error initializing Tone.js:", error); } }
        function playSound(type, note = null, duration = '8n') { if (!soundsReady || !synths[type]) return; try { if (type === 'feedbackNegative' || type === 'dash' || type === 'hazardWarn' || type === 'laserFire' || type === 'rivalDestroyed' || type === 'playerHit' || type === 'gameOver') { if (type === 'feedbackNegative') synths[type].triggerAttackRelease(duration); else if (type === 'dash') synths[type].triggerAttackRelease('C4', duration); else if (type === 'hazardWarn') synths[type].triggerAttackRelease('A4', '16n'); else if (type === 'laserFire') synths[type].triggerAttackRelease('G5', '16n'); else if (type === 'rivalDestroyed') synths[type].triggerAttackRelease(); else if (type === 'playerHit') synths[type].triggerAttackRelease('C3', '8n'); else if (type === 'gameOver') synths[type].triggerAttackRelease('C2', '1n'); } else if (note) { synths[type].triggerAttackRelease(note, duration); } } catch (error) { console.error(`Error playing sound ${type}:`, error); } }

        // --- Game Objects --- (Unchanged definitions)
        const player = {
            x: 50, y: 50, width: 56, height: 56, speed: 180, /* Base speed in pixels per second */
            isDashing: false, dashCooldown: 1500, lastDashTime: 0, dashDuration: 250, dashParticles: [],
            laserCooldown: 2000, lastLaserTime: 0, isFiringLaser: false, laserDuration: 150, laserRange: 300, laserWidth: 5,
            lastMoveDx: 1, lastMoveDy: 0, isInvulnerable: false, invulnerabilityDuration: 1000, lastHitTime: 0,
            img: null,
            loadImage: async function() {
                return new Promise((resolve) => {
                    this.img = new Image();
                    this.img.onload = () => resolve();
                    this.img.onerror = () => {
                        console.error("Failed to load player image");
                        resolve();
                    };
                    this.img.src = 'k2.png';
                });
            }
        };
        // Initial image load
        player.loadImage();
        const rivals = []; const rivalBaseSpeed = 60; /* Base speed in pixels per second */ const rivalHazardRadius = 50; const rivalHazardWarningDuration = 800; const rivalHazardActiveDuration = 1000;
        // Array of rival images
        const rivalImages = [
            { img: new Image(), src: 'doge.png' },
            { img: new Image(), src: 'shaggy.png' },
            { img: new Image(), src: 'shiba.png' },
            { img: new Image(), src: 'pepe.png' }
        ];
        // Load all rival images
        rivalImages.forEach(rivalImg => {
            rivalImg.img.src = rivalImg.src;
        });
        // Function to get random rival image
        function getRandomRivalImage() {
            const randomIndex = Math.floor(Math.random() * rivalImages.length);
            return rivalImages[randomIndex].img;
        }
        const targetZone = { x: 600, y: 400, radius: 40, color: 'rgba(0, 255, 0, 0.3)', borderColor: '#00ff00', element: null };
        const collectibles = []; const collectibleRadius = 10; const collectibleWidth = 15; const collectibleHeight = 10;
        const particles = [];
        const feedbackMessages = [ /* ... Unchanged ... */ { trigger: 'dash', text: '#KovuBoost!', approval: 3, sound: 'dash' }, { trigger: 'halfway', text: 'Looking good! #Progress', approval: 5, sound: 'feedbackPositive', note: 'G4' }, { trigger: 'dodge', text: 'Nice dodge! #Skillz', approval: 4, sound: 'feedbackPositive', note: 'A4' }, { trigger: 'hazard_hit', text: 'Hazard Hit! Approval Lost!', approval: -15, sound: 'playerHit', negative: true }, { trigger: 'rival_collision', text: 'Collision! Ouch!', approval: -10, sound: 'playerHit', negative: true }, { trigger: 'collect', text: 'Data Packet! +Approval!', approval: 5, sound: 'collect', note: 'C5' }, { trigger: 'destroy_rival', text: 'Rival Deleted! #LaserFocus', approval: 10, sound: 'rivalDestroyed' }, { trigger: 'win', text: '#Victory! Community Morale Soaring!', approval: 20, sound: 'win', note: 'C5' } ];
        let halfwayReached = false;

        // --- Initialization --- (Unchanged functions: loadSvg, createDisintegrationEffect)
        function loadSvg(svgString, width, height) { return new Promise((resolve) => { const blob = new Blob([svgString], { type: 'image/svg+xml' }); const url = URL.createObjectURL(blob); const img = new Image(); img.onload = () => { URL.revokeObjectURL(url); resolve(img); }; img.onerror = () => { console.error("Failed to load SVG image"); resolve(null); }; img.width = width; img.height = height; img.src = url; }); }
        function createDisintegrationEffect(x, y, count = 20) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 2 + 1; particles.push({ x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: Math.random() * 2.5 + 1, color: `rgba(${240 + Math.random() * 15}, ${190 + Math.random() * 30}, ${15 + Math.random() * 30}, ${0.8 + Math.random() * 0.2})`, life: 20 + Math.random() * 20, initialLife: 40 }); } }
        function spawnCollectibles(levelConf) { /* ... Unchanged ... */ collectibles.length = 0; totalCollectibles = levelConf.numCollectibles; collectiblesCollected = 0; isTargetZoneActive = false; const topMargin = 40; const bottomMargin = 50; for (let i = 0; i < totalCollectibles; i++) { let placed = false; let attempts = 0; while (!placed && attempts < 100) { attempts++; const potentialX = collectibleRadius + Math.random() * (canvasWidth - collectibleRadius * 2); const potentialY = topMargin + Math.random() * (canvasHeight - topMargin - bottomMargin); if (potentialY < topMargin || potentialY > canvasHeight - bottomMargin) continue; const distToPlayerStart = Math.sqrt(Math.pow(potentialX - canvasWidth / 4, 2) + Math.pow(potentialY - canvasHeight / 2, 2)); const distToTarget = Math.sqrt(Math.pow(potentialX - targetZone.x, 2) + Math.pow(potentialY - targetZone.y, 2)); let tooCloseToRivalStart = false; for(const r of rivals) { if (!r.isDestroyed) { const distToRival = Math.sqrt(Math.pow(potentialX - r.startX, 2) + Math.pow(potentialY - r.startY, 2)); if (distToRival < r.width * 2) { tooCloseToRivalStart = true; break; } } } if (distToPlayerStart > player.width * 2 && distToTarget > targetZone.radius * 1.5 && !tooCloseToRivalStart) { collectibles.push({ x: potentialX, y: potentialY, radius: collectibleRadius, collected: false }); placed = true; } } if (attempts >= 100) console.warn("Could not place all collectibles easily."); } console.log(`Level ${levelConf.level}: Spawned ${collectibles.length} Collectibles`); updateObjectiveText(); }
        function updateObjectiveText() { /* ... Unchanged ... */ if (isTargetZoneActive) { objectiveDisplay.textContent = levelConfigs[currentLevel - 1].objectiveText; } else { objectiveDisplay.textContent = `Collect Data! (${collectiblesCollected}/${totalCollectibles})`; } }
        async function setupGame(levelIndex) { /* ... Added logging ... */ const levelConf = levelConfigs[levelIndex]; if (!levelConf) { console.error("Invalid level index:", levelIndex); gameState = 'win'; winMessage.style.display = 'flex'; winMessage.style.opacity = 1; return; } console.log(`Setting up Level ${levelConf.level}`); currentLevel = levelConf.level; canvasWidth = gameContainer.clientWidth; canvasHeight = gameContainer.clientHeight; canvas.width = canvasWidth; canvas.height = canvasHeight; levelIndicator.textContent = `Level: ${levelConf.level}`; player.x = canvasWidth / 4; player.y = canvasHeight / 2; player.lastMoveDx = 1; player.lastMoveDy = 0; targetZone.x = canvasWidth * levelConf.targetXRatio; targetZone.y = canvasHeight * levelConf.targetYRatio; if (!player.img) player.img = await loadSvg(player.svg, player.width, player.height); if (!rivalImages[0].img) rivalImages[0].img = await loadSvg(rivalSvg, 38, 38); rivals.length = 0; document.querySelectorAll('.dogen-hazard').forEach(el => el.remove()); particles.length = 0; for (let i = 0; i < levelConf.numRivals; i++) { const startX = canvasWidth * (0.5 + Math.random() * 0.3); const startY = canvasHeight * (0.15 + Math.random() * 0.7); const patrolRange = 70 + Math.random() * 60;
            const speed = rivalBaseSpeed * levelConf.rivalSpeedMultiplier * (0.8 + Math.random() * 0.4);
            const hazardCooldown = levelConf.rivalHazardCooldownBase; const hazardRandomDelay = Math.random() * 1500; const hazardElement = document.createElement('div'); hazardElement.className = 'dogen-hazard'; hazardElement.style.width = `${rivalHazardRadius * 2}px`; hazardElement.style.height = `${rivalHazardRadius * 2}px`; gameContainer.appendChild(hazardElement); rivals.push({
                    x: startX,
                    y: startY,
                    width: 38,
                    height: 38,
                    speed: speed,
                    direction: Math.random() < 0.5 ? 1 : -1,
                    patrolRange: patrolRange,
                    startX: startX,
                    startY: startY,
                    img: getRandomRivalImage(), // Use random rival image
                    hazardActive: false,
                    isInWarning: false,
                    lastHazardTime: Date.now() - Math.random() * hazardCooldown,
                    hazardElement: hazardElement,
                    hazardFeedbackGiven: false,
                    dodgeFeedbackGiven: false,
                    isDestroyed: false,
                    hazardCooldown: hazardCooldown,
                    hazardTimer: hazardCooldown + hazardRandomDelay,
                    hazardTargetX: 0,
                    hazardTargetY: 0
                });
            }
            console.log(`Level ${levelConf.level}: Initialized Rivals Array:`, JSON.parse(JSON.stringify(rivals))); // Log created rivals
            if (!targetZone.element) { targetZone.element = document.createElement('div'); targetZone.element.className = 'target-zone'; gameContainer.appendChild(targetZone.element); } targetZone.element.style.left = `${targetZone.x - targetZone.radius}px`; targetZone.element.style.top = `${targetZone.y - targetZone.radius}px`; targetZone.element.style.width = `${targetZone.radius * 2}px`; targetZone.element.style.height = `${targetZone.radius * 2}px`; targetZone.element.classList.remove('active'); spawnCollectibles(levelConf); joystickDimensionsCalculated = false; console.log(`Level ${levelConf.level} setup complete.`); }
        window.addEventListener('resize', () => { if (gameState === 'playing' || gameState === 'level_transition') { setupGame(currentLevel - 1); } });
        // Enhanced intro panel handling with touch support
        function showIntroPanel(panelNumber) {
                    console.log("Transitioning to intro panel:", panelNumber);
                    
                    const currentPanel = document.querySelector('.intro-panel.active');
                    const nextPanel = document.querySelector(`.intro-panel[data-panel="${panelNumber}"]`);
                    
                    if (!nextPanel) {
                        console.error("Could not find panel:", panelNumber);
                        return;
                    }
                    
                    // Fade out current panel
                    if (currentPanel) {
                        currentPanel.style.opacity = '0';
                        setTimeout(() => {
                            currentPanel.style.display = 'none';
                            currentPanel.classList.remove('active');
                            
                            // Show next panel
                            nextPanel.style.display = 'block';
                            // Force reflow
                            nextPanel.offsetHeight;
                            nextPanel.classList.add('active');
                            nextPanel.style.opacity = '1';
                            console.log("Panel transition complete:", nextPanel.dataset.panel);
                        }, 300);
                    }
                }
        
                function setupIntroTouchHandlers() {
                    // Add CSS for smooth transitions
                    const style = document.createElement('style');
                    style.textContent = `
                        .intro-panel {
                            transition: opacity 0.3s ease;
                            opacity: 0;
                            pointer-events: none;
                            display: none;
                        }
                        .intro-panel.active {
                            opacity: 1;
                            pointer-events: auto;
                            display: block;
                        }
                        #intro-overlay button {
                            transition: transform 0.2s ease;
                            cursor: pointer;
                            padding: 10px 20px;
                            background: linear-gradient(45deg, #f95738, #ff8c42);
                            border: none;
                            border-radius: 8px;
                            color: white;
                            font-family: 'Press Start 2P', cursive;
                            font-size: 0.8rem;
                            text-transform: uppercase;
                        }
                        #intro-overlay button:active {
                            transform: scale(0.95);
                        }
                    `;
                    document.head.appendChild(style);
        
                    // Set initial panel state
                    const initialPanel = document.querySelector('.intro-panel.active');
                    if (initialPanel) {
                        initialPanel.style.display = 'block';
                        initialPanel.style.opacity = '1';
                    }
        
                    // Handle button clicks
                    const introButtons = document.querySelectorAll('#intro-overlay button');
                    introButtons.forEach(button => {
                        const handleClick = (e) => {
                            e.preventDefault();
                            const currentPanel = button.closest('.intro-panel');
                            if (!currentPanel || !currentPanel.classList.contains('active')) {
                                console.log("Invalid click - panel not active");
                                return;
                            }
                            
                            const nextAction = button.dataset.next;
                            console.log("Next action:", nextAction);
                            
                            if (nextAction === 'start') {
                                console.log("Starting game from final panel");
                                currentPanel.style.opacity = '0';
                                setTimeout(() => {
                                    currentPanel.style.display = 'none';
                                    currentPanel.classList.remove('active');
                                    startGame();
                                }, 300);
                            } else {
                                const nextPanelNumber = parseInt(nextAction);
                                if (!isNaN(nextPanelNumber)) {
                                    showIntroPanel(nextPanelNumber);
                                }
                            }
                        };
        
                        // Add both touch and click handlers with debounce
                        let isHandling = false;
                        const debouncedHandler = (e) => {
                            if (isHandling) {
                                console.log("Ignoring click - already handling");
                                return;
                            }
                            isHandling = true;
                            handleClick(e);
                            setTimeout(() => { isHandling = false; }, 300);
                        };
        
                        button.addEventListener('touchstart', debouncedHandler, { passive: false });
                        button.addEventListener('click', debouncedHandler);
                    });
                }
        function startGame() { /* ... Unchanged ... */ console.log("startGame function called"); currentLevel = 1; if (Tone.context.state !== 'running') { Tone.start().then(() => { console.log("AudioContext started!"); setupSounds(); proceedWithGameStart(); }).catch(e => { console.error("Tone.start() failed:", e); proceedWithGameStart(); }); } else { if (!soundsReady) setupSounds(); proceedWithGameStart(); } }
        function proceedWithGameStart() {
            console.log("Proceeding with game start...");
            
            // Hide all overlays
            introOverlay.style.display = 'none';
            introOverlay.style.opacity = 0;
            winMessage.style.display = 'none';
            winMessage.style.opacity = 0;
            levelTransitionOverlay.style.display = 'none';
            levelTransitionOverlay.style.opacity = 0;
            gameOverOverlay.style.display = 'none';
            gameOverOverlay.style.opacity = 0;
            
            // Reset game state before setup
            resetGameState(currentLevel - 1);
            
            // Set game state to playing before setup to ensure rivals are active
            gameState = 'playing';
            
            // Setup the game
            setupGame(currentLevel - 1).then(() => {
                console.log("Game setup complete, starting game loop");
                kccStatusElement.innerHTML = 'ðŸŸ¢<span>LIVE</span>';
                kccStatusElement.classList.add('live');
                lastTimestamp = performance.now(); // Initialize timestamp for delta time
                 if (animationFrameId) cancelAnimationFrame(animationFrameId); gameLoop(); console.log("Game Started - Level", currentLevel); }).catch(err => { console.error("Error during setupGame in proceedWithGameStart:", err); }); }
        function restartGame() { /* ... Unchanged ... */ winMessage.style.display = 'none'; winMessage.style.opacity = 0; gameOverOverlay.style.display = 'none'; gameOverOverlay.style.opacity = 0; startGame(); }
        function resetGameState(levelIndex) { /* ... Unchanged ... */ const levelConf = levelConfigs[levelIndex]; if (!levelConf) return; player.isDashing = false; player.lastDashTime = 0; player.dashParticles = []; player.isFiringLaser = false; player.lastLaserTime = 0; player.isInvulnerable = false; player.lastHitTime = 0; /* tapDashActive removed */ rivals.forEach(rival => { rival.isDestroyed = false; rival.hazardActive = false; rival.isInWarning = false; rival.hazardFeedbackGiven = false; rival.dodgeFeedbackGiven = false; if (rival.hazardElement) { rival.hazardElement.classList.remove('active', 'warning'); rival.hazardElement.style.opacity = 0; if (!rival.hazardElement.parentNode) { gameContainer.appendChild(rival.hazardElement); } } }); approvalMeter.value = 10; feedbackArea.innerHTML = ''; halfwayReached = false; particles.length = 0; collectiblesCollected = 0; isTargetZoneActive = false; if(targetZone.element) targetZone.element.classList.remove('active'); }

        // --- Input Handling --- (Unchanged)
        // Keyboard Handling
        window.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); keys[key] = true; if (["arrowup", "arrowdown", "arrowleft", "arrowright", " ", "e"].includes(key)) { e.preventDefault(); } if (key === 'e' && gameState === 'playing' && !player.isFiringLaser && Date.now() - player.lastLaserTime > player.laserCooldown) { fireLaser(); } });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        // Game area tap handling
        let lastTapTime = 0;
        const doubleTapDelay = 300; // Time window for double tap in milliseconds

        function handleGameAreaTap(event) {
                            event.preventDefault();
                            if (gameState !== 'playing') return;
                            
                            // Check if tap is on laser button or joystick
                            const target = event.target;
                            if (target.id === 'laser-button' ||
                                target.className === 'laser-button-inner' ||
                                target.id === 'joystick-area' ||
                                target.id === 'joystick-base' ||
                                target.id === 'joystick-knob') {
                                return;
                            }
                
                            const currentTime = Date.now();
                            const touch = event.touches[0];
                            const rect = canvas.getBoundingClientRect();
                            const tapX = touch.clientX - rect.left;
                            const tapY = touch.clientY - rect.top;
                            const scaleX = canvas.width / rect.width;
                            const scaleY = canvas.height / rect.height;
                            const gameX = tapX * scaleX;
                            const gameY = tapY * scaleY;
                
                            // Check if tap hits any rival with a larger hit area
                            let rivalHit = false;
                            for (const rival of rivals) {
                                if (!rival.isDestroyed) {
                                    // Add a margin around the rival for easier tapping
                                    const hitMargin = 30;
                                    const rivalCenterX = rival.x + rival.width/2;
                                    const rivalCenterY = rival.y + rival.height/2;
                                    const dx = gameX - rivalCenterX;
                                    const dy = gameY - rivalCenterY;
                                    const distanceSquared = dx * dx + dy * dy;
                                    const hitRadius = rival.width/2 + hitMargin;
                                    
                                    if (distanceSquared <= hitRadius * hitRadius) {
                                        rivalHit = true;
                                        console.log("Rival tapped!");
                                        
                                        // Calculate direction from player to rival
                                        const toRivalX = rivalCenterX - (player.x + player.width/2);
                                        const toRivalY = rivalCenterY - (player.y + player.height/2);
                                        const dist = Math.sqrt(toRivalX * toRivalX + toRivalY * toRivalY);
                                        
                                        // Update player's aim direction
                                        player.lastMoveDx = toRivalX / dist;
                                        player.lastMoveDy = toRivalY / dist;
                                        
                                        // Fire laser if cooldown allows
                                        if (!player.isFiringLaser && currentTime - player.lastLaserTime > player.laserCooldown) {
                                            fireLaser();
                                        }
                                        break;
                                    }
                                }
                            }
                
                            // If no rival was hit, perform dash towards tap location
                            if (!rivalHit && !player.isDashing && currentTime - player.lastDashTime > player.dashCooldown) {
                                // Calculate dash direction from player to tap location
                                const playerCenterX = player.x + player.width/2;
                                const playerCenterY = player.y + player.height/2;
                                const dx = gameX - playerCenterX;
                                const dy = gameY - playerCenterY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist > 0) {  // Prevent division by zero
                                    // Update movement direction for dash
                                    player.lastMoveDx = dx / dist;
                                    player.lastMoveDy = dy / dist;
                                    
                                    console.log("Dashing towards:", {x: gameX, y: gameY});
                                    player.isDashing = true;
                                    player.lastDashTime = currentTime;
                                    triggerFeedback('dash');
                                    
                                    // Create initial dash particles
                                    player.dashParticles.push({
                                        x: playerCenterX,
                                        y: playerCenterY,
                                        life: 20
                                    });
                                    
                                    setTimeout(() => {
                                        player.isDashing = false;
                                    }, player.dashDuration);
                                }
                            }
                        }
        // Joystick Touch Handling
        joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joystickActive = true; joystickArea.classList.add('active'); const touch = e.changedTouches[0]; joystickStartX = touch.clientX; joystickStartY = touch.clientY; }, { passive: false });
        joystickArea.addEventListener('touchmove', (e) => { e.preventDefault(); if (!joystickActive) return; if (!joystickDimensionsCalculated || maxJoystickDist <= 0) return; const touch = e.changedTouches[0]; const currentX = touch.clientX; const currentY = touch.clientY; const areaRect = joystickArea.getBoundingClientRect(); const areaCenterX = areaRect.left + areaRect.width / 2; const areaCenterY = areaRect.top + areaRect.height / 2; let dx = currentX - areaCenterX; let dy = currentY - areaCenterY; const dist = Math.sqrt(dx * dx + dy * dy); const angle = Math.atan2(dy, dx); const clampedDist = Math.min(dist, maxJoystickDist); const knobX = clampedDist * Math.cos(angle); const knobY = clampedDist * Math.sin(angle); joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`; const deadZone = maxJoystickDist * 0.15; if (clampedDist > deadZone) { const magnitude = Math.sqrt(dx * dx + dy * dy); joystickDx = dx / magnitude; joystickDy = dy / magnitude; /* joystickMagnitude removed */ } else { joystickDx = 0; joystickDy = 0; /* joystickMagnitude removed */ } }, { passive: false });
        joystickArea.addEventListener('touchend', (e) => { e.preventDefault(); if (!joystickActive) return; joystickActive = false; joystickArea.classList.remove('active'); joystickKnob.style.transform = `translate(-50%, -50%)`; joystickDx = 0; joystickDy = 0; /* joystickMagnitude removed */ }, { passive: false });

        // --- Laser Firing Logic --- (Unchanged)
        function fireLaser() { 
            if (player.isFiringLaser || Date.now() - player.lastLaserTime < player.laserCooldown) return; 
            player.isFiringLaser = true; 
            player.lastLaserTime = Date.now(); 
            playSound('laserFire'); 
            const laserDx = player.lastMoveDx; 
            const laserDy = player.lastMoveDy; 
            const laserStartX = player.x + player.width / 2 + laserDx * (player.width * 0.4); 
            const laserStartY = player.y + player.height / 2 + laserDy * (player.height * 0.4); 
            const laserEndX = laserStartX + laserDx * player.laserRange; 
            const laserEndY = laserStartY + laserDy * player.laserRange; 
            let rivalHit = false; 

            // Increase laser width for more forgiving hit detection
            const effectiveLaserWidth = player.laserWidth * 2.5; // Increased from base width

            for (const rival of rivals) { 
                if (!rival.isDestroyed && !rivalHit) { 
                    const rivalCenterX = rival.x + rival.width / 2; 
                    const rivalCenterY = rival.y + rival.height / 2; 
                    const rivalRadius = rival.width / 2; 

                    // Calculate distance from rival to laser line
                    const sx = rivalCenterX - laserStartX; 
                    const sy = rivalCenterY - laserStartY; 
                    const segDx = laserEndX - laserStartX; 
                    const segDy = laserEndY - laserStartY; 
                    const segLenSq = segDx * segDx + segDy * segDy; 
                    let t = 0; 
                    if (segLenSq > 0) { 
                        t = (sx * segDx + sy * segDy) / segLenSq; 
                        t = Math.max(0, Math.min(1, t)); 
                    } 
                    const closestX = laserStartX + t * segDx; 
                    const closestY = laserStartY + t * segDy; 
                    const distSq = Math.pow(rivalCenterX - closestX, 2) + Math.pow(rivalCenterY - closestY, 2); 

                    // More forgiving hit detection with increased hit area
                    const hitThreshold = rivalRadius + effectiveLaserWidth / 2;
                    const hitMargin = rivalRadius * 0.5; // Additional margin for near misses

                    if (distSq < (hitThreshold + hitMargin) * (hitThreshold + hitMargin)) { 
                        console.log("Rival Hit!"); 
                        rival.isDestroyed = true; 
                        rivalHit = true; 
                        triggerFeedback('destroy_rival'); 
                        createDisintegrationEffect(rivalCenterX, rivalCenterY); 
                        if (rival.hazardElement && rival.hazardElement.parentNode) { 
                            rival.hazardElement.parentNode.removeChild(rival.hazardElement); 
                        } 
                        break; 
                    } 
                } 
            } 
            setTimeout(() => { player.isFiringLaser = false; }, player.laserDuration); 
        }

        // --- Damage Application Function --- (Unchanged)
        function applyDamage(type) {
            if (player.isInvulnerable) return;
            
            // Set invulnerability state
            player.isInvulnerable = true;
            player.lastHitTime = Date.now();
            
            // Add visual feedback class
            const playerElement = document.querySelector('.kovu-svg');
            if (playerElement) {
                playerElement.classList.add('player-invulnerable');
                setTimeout(() => {
                    playerElement.classList.remove('player-invulnerable');
                }, player.invulnerabilityDuration);
            }
            
            // Trigger feedback and sound
            triggerFeedback(type);
            
            // Reset invulnerability after duration
            setTimeout(() => {
                player.isInvulnerable = false;
            }, player.invulnerabilityDuration);
        }

        // --- Game Over Trigger --- (Unchanged)
        function triggerGameOver() { if (gameState === 'gameOver') return; console.log("Game Over triggered!"); gameState = 'gameOver'; if (animationFrameId) cancelAnimationFrame(animationFrameId); playSound('gameOver'); levelTransitionOverlay.style.display = 'none'; levelTransitionOverlay.style.opacity = 0; winMessage.style.display = 'none'; winMessage.style.opacity = 0; gameOverOverlay.style.display = 'flex'; setTimeout(() => { gameOverOverlay.style.opacity = 1; }, 50); kccStatusElement.innerHTML = 'ðŸ”´<span>OFFLINE</span>'; kccStatusElement.classList.remove('live'); }

        // --- Game Logic (Update - Modified Movement Speed) ---
        function update(deltaTime) { // Accept deltaTime
            if (gameState !== 'playing') return;
            const now = Date.now();
            // --- Base speed is now pixels per second ---
            let currentSpeed = player.speed;

            if (player.isInvulnerable && now - player.lastHitTime > player.invulnerabilityDuration) { player.isInvulnerable = false; }

            // --- Movement Logic (Keyboard/Joystick) ---
            let moveX = 0; let moveY = 0;
            let isMoving = false;

            // Prioritize Joystick Input if active
            if (joystickActive && (joystickDx !== 0 || joystickDy !== 0)) {
                 moveX = joystickDx;
                 moveY = joystickDy;
                 // Speed is now constant when joystick is active outside deadzone
                 currentSpeed = player.speed;
                 isMoving = true;
                 player.lastMoveDx = joystickDx;
                 player.lastMoveDy = joystickDy;
            } else {
                // Keyboard Input (Fallback)
                let keyMoveX = 0; let keyMoveY = 0;
                if (keys['arrowup'] || keys['w']) { keyMoveY -= 1; isMoving = true; }
                if (keys['arrowdown'] || keys['s']) { keyMoveY += 1; isMoving = true; }
                if (keys['arrowleft'] || keys['a']) { keyMoveX -= 1; isMoving = true; }
                if (keys['arrowright'] || keys['d']) { keyMoveX += 1; isMoving = true; }

                const keyMagnitude = Math.sqrt(keyMoveX * keyMoveX + keyMoveY * keyMoveY);
                if (keyMagnitude > 0) {
                    moveX = keyMoveX / keyMagnitude;
                    moveY = keyMoveY / keyMagnitude;
                    player.lastMoveDx = moveX;
                    player.lastMoveDy = moveY;
                    currentSpeed = player.speed; // Base speed for keyboard
                } else {
                    moveX = 0; moveY = 0;
                }
            }

            // Apply Keyboard/Joystick Movement (Factoring in Delta Time)
            if (isMoving) {
                 player.x += moveX * currentSpeed * deltaTime;
                 player.y += moveY * currentSpeed * deltaTime;
            }

            // Keyboard/Button Dash Activation & Boost
            if (keys[' '] && !player.isDashing && now - player.lastDashTime > player.dashCooldown) {
                 player.isDashing = true;
                 player.lastDashTime = now;
                 triggerFeedback('dash');
                 setTimeout(() => { player.isDashing = false; }, player.dashDuration);
            }
            if (player.isDashing && isMoving) { // Boost only for keyboard/button dash
                  const boostSpeed = player.speed * 2.0; // Pixels per second boost
                  player.x += moveX * boostSpeed * deltaTime;
                  player.y += moveY * boostSpeed * deltaTime;
                  player.dashParticles.push({ x: player.x + player.width / 2, y: player.y + player.height / 2, life: 20 });
            }


            // Update dash particles & Keep player in bounds (Unchanged)
            player.dashParticles = player.dashParticles.filter(p => p.life > 0); player.dashParticles.forEach(p => p.life--);
            player.x = Math.max(0, Math.min(canvasWidth - player.width, player.x)); player.y = Math.max(0, Math.min(canvasHeight - player.height, player.y));
            particles.forEach((p, index) => { p.x += p.vx * deltaTime * 60; p.y += p.vy * deltaTime * 60; p.life -= deltaTime * 60; if (p.life <= 0) { particles.splice(index, 1); } }); // Update particles based on delta time

            // Update Each Rival & Check Hazard Hits
            console.log(`Updating rivals. Game state: ${gameState}, Rival count: ${rivals.length}`);
            rivals.forEach((rival, index) => {
                // Debug rival status
                console.log(`Rival ${index}: Position(${rival.x.toFixed(1)}, ${rival.y.toFixed(1)}), Direction: ${rival.direction}, Speed: ${rival.speed}, Destroyed: ${rival.isDestroyed}`);
                
                if (rival.isDestroyed) {
                    if (rival.hazardElement && rival.hazardElement.style.opacity !== '0') {
                        rival.hazardElement.style.opacity = '0';
                        rival.hazardElement.classList.remove('active', 'warning');
                    }
                    return;
                }

                // --- Refined Rival Movement (Factoring in Delta Time) ---
                // Ensure rival has valid initial position
                if (typeof rival.x !== 'number' || isNaN(rival.x)) {
                    rival.x = rival.startX;
                }
                
                // Calculate movement for this frame
                const rivalSpeedThisFrame = rival.speed * deltaTime;
                const intendedX = rival.x + (rivalSpeedThisFrame * rival.direction);
                
                // Calculate patrol boundaries
                const patrolLeftBound = Math.max(0, rival.startX - rival.patrolRange);
                const patrolRightBound = Math.min(canvasWidth - rival.width, rival.startX + rival.patrolRange);
                
                // Check if we need to reverse direction
                if ((rival.direction === 1 && intendedX >= patrolRightBound) ||
                    (rival.direction === -1 && intendedX <= patrolLeftBound)) {
                    rival.direction *= -1;
                }
                
                // Update position with bounds checking
                rival.x = Math.max(patrolLeftBound, Math.min(patrolRightBound, intendedX));
                rival.y = Math.max(0, Math.min(canvasHeight - rival.height, rival.y));


                // Hazard Logic (Unchanged)
                if (!rival.isInWarning && !rival.hazardActive && now - rival.lastHazardTime > rival.hazardTimer) { rival.isInWarning = true; rival.lastHazardTime = now; playSound('hazardWarn'); const predictDistance = 50; const randomOffsetRange = 40; const targetBaseX = player.x + player.width / 2 + player.lastMoveDx * predictDistance; const targetBaseY = player.y + player.height / 2 + player.lastMoveDy * predictDistance; rival.hazardTargetX = targetBaseX + (Math.random() - 0.5) * randomOffsetRange; rival.hazardTargetY = targetBaseY + (Math.random() - 0.5) * randomOffsetRange; rival.hazardTargetX = Math.max(rivalHazardRadius, Math.min(canvasWidth - rivalHazardRadius, rival.hazardTargetX)); rival.hazardTargetY = Math.max(rivalHazardRadius, Math.min(canvasHeight - rivalHazardRadius, rival.hazardTargetY)); if (rival.hazardElement) { rival.hazardElement.style.left = `${rival.hazardTargetX - rivalHazardRadius}px`; rival.hazardElement.style.top = `${rival.hazardTargetY - rivalHazardRadius}px`; rival.hazardElement.classList.add('warning'); rival.hazardElement.style.opacity = 0.8; } setTimeout(() => { if (!rival.isInWarning) return; rival.isInWarning = false; rival.hazardActive = true; rival.hazardFeedbackGiven = false; rival.dodgeFeedbackGiven = false; if (rival.hazardElement) { rival.hazardElement.classList.remove('warning'); rival.hazardElement.classList.add('active'); } setTimeout(() => { if (!rival.hazardActive) return; rival.hazardActive = false; rival.lastHazardTime = Date.now(); rival.hazardTimer = rival.hazardCooldown + Math.random() * 1500; if (rival.hazardElement) { rival.hazardElement.classList.remove('active'); rival.hazardElement.style.opacity = 0; } }, rivalHazardActiveDuration); }, rivalHazardWarningDuration); }
                // Hazard Collision Checks (Unchanged)
                if (rival.hazardActive && !player.isInvulnerable) { const dx = (player.x + player.width / 2) - rival.hazardTargetX; const dy = (player.y + player.height / 2) - rival.hazardTargetY; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < rivalHazardRadius + player.width / 2) { applyDamage('hazard_hit'); } }
                if (player.isDashing && rival.hazardActive) { const dx = (player.x + player.width / 2) - rival.hazardTargetX; const dy = (player.y + player.height / 2) - rival.hazardTargetY; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < rivalHazardRadius + player.width * 1.5 && distance > rivalHazardRadius - player.width) { if (!rival.dodgeFeedbackGiven) { triggerFeedback('dodge'); rival.dodgeFeedbackGiven = true; setTimeout(() => { rival.dodgeFeedbackGiven = false; }, 500); } } }
            });

            // Check Player Damage from Direct Rival Collision with circular hitboxes
            if (!player.isInvulnerable) {
                rivals.forEach(rival => {
                    if (!rival.isDestroyed) {
                        // Calculate centers
                        const playerCenterX = player.x + player.width / 2;
                        const playerCenterY = player.y + player.height / 2;
                        const rivalCenterX = rival.x + rival.width / 2;
                        const rivalCenterY = rival.y + rival.height / 2;
                        
                        // Calculate distance between centers
                        const dx = playerCenterX - rivalCenterX;
                        const dy = playerCenterY - rivalCenterY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // More forgiving collision radius (70% of combined dimensions)
                        const collisionRadius = (player.width + rival.width) * 0.35;
                        
                        if (distance < collisionRadius) {
                            applyDamage('rival_collision');
                        }
                    }
                });
            }

            // Check halfway point (Unchanged)
            if (!halfwayReached && player.x > canvasWidth / 2) { halfwayReached = true; triggerFeedback('halfway'); }
            // Check Collectible Collision & Target Activation (Unchanged)
            for (let i = collectibles.length - 1; i >= 0; i--) { const collectible = collectibles[i]; if (!collectible.collected) { const dx = (player.x + player.width / 2) - collectible.x; const dy = (player.y + player.height / 2) - collectible.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < collectible.radius + player.width / 2) { collectible.collected = true; collectiblesCollected++; triggerFeedback('collect'); updateObjectiveText(); if (collectiblesCollected >= totalCollectibles && !isTargetZoneActive) { isTargetZoneActive = true; console.log("All collectibles gathered! Target zone active."); if(targetZone.element) targetZone.element.classList.add('active'); updateObjectiveText(); } } } }
            // Check Level Win Condition (Unchanged)
            if (isTargetZoneActive) { const distToTargetX = player.x + player.width / 2 - targetZone.x; const distToTargetY = player.y + player.height / 2 - targetZone.y; const distanceToTarget = Math.sqrt(distToTargetX * distToTargetX + distToTargetY * distToTargetY); if (distanceToTarget < targetZone.radius + player.width / 2) { if (currentLevel < levelConfigs.length) { gameState = 'level_transition'; if (animationFrameId) cancelAnimationFrame(animationFrameId); playSound('win', 'C5'); levelTransitionOverlay.style.display = 'flex'; levelTransitionOverlay.style.opacity = 1; kccStatusElement.innerHTML = 'ðŸ”´<span>OFFLINE</span>'; kccStatusElement.classList.remove('live'); setTimeout(() => { levelTransitionOverlay.style.display = 'none'; levelTransitionOverlay.style.opacity = 0; currentLevel++; resetGameState(currentLevel - 1); setupGame(currentLevel - 1).then(() => { gameState = 'playing'; kccStatusElement.innerHTML = 'ðŸŸ¢<span>LIVE</span>'; kccStatusElement.classList.add('live'); gameLoop(); }); }, 2500); } else { gameState = 'win'; triggerFeedback('win'); winMessage.style.display = 'flex'; winMessage.style.opacity = 1; kccStatusElement.innerHTML = 'ðŸ”´<span>OFFLINE</span>'; kccStatusElement.classList.remove('live'); if (animationFrameId) cancelAnimationFrame(animationFrameId); console.log("All levels complete!"); } } }
        }

        // --- Rendering ---
        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            // Background elements & grid (Unchanged)
            ctx.fillStyle = 'rgba(74, 74, 138, 0.1)'; ctx.fillRect(canvasWidth * 0.1, canvasHeight * 0.1, canvasWidth * 0.2, canvasHeight * 0.15); ctx.fillRect(canvasWidth * 0.7, canvasHeight * 0.6, canvasWidth * 0.15, canvasHeight * 0.2); ctx.strokeStyle = 'rgba(74, 74, 138, 0.2)'; ctx.strokeRect(canvasWidth * 0.5, canvasHeight * 0.2, canvasWidth * 0.25, canvasHeight * 0.3);
            ctx.strokeStyle = 'rgba(74, 74, 138, 0.2)'; ctx.lineWidth = 1; for (let x = 0; x < canvasWidth; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvasHeight); ctx.stroke(); } for (let y = 0; y < canvasHeight; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y); ctx.stroke(); }
            // Collectibles (Unchanged)
            collectibles.forEach(collectible => { if (!collectible.collected) { const packetX = collectible.x - collectibleWidth / 2; const packetY = collectible.y - collectibleHeight / 2; ctx.fillStyle = '#00ffff'; ctx.fillRect(packetX, packetY, collectibleWidth, collectibleHeight); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(packetX + 2, packetY + 2); ctx.lineTo(packetX + collectibleWidth - 2, packetY + 2); ctx.moveTo(packetX + 2, packetY + collectibleHeight / 2); ctx.lineTo(packetX + collectibleWidth - 2, packetY + collectibleHeight / 2); ctx.moveTo(packetX + 2, packetY + collectibleHeight - 2); ctx.lineTo(packetX + collectibleWidth - 2, packetY + collectibleHeight - 2); ctx.stroke(); ctx.shadowColor = 'rgba(0, 255, 255, 0.5)'; ctx.shadowBlur = 5; ctx.fillStyle = '#00ffff'; ctx.fillRect(packetX, packetY, collectibleWidth, collectibleHeight); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; } });
            // Player (Unchanged)
            ctx.save(); if (player.isInvulnerable) { ctx.globalAlpha = (Math.floor(Date.now() / 100) % 2 === 0) ? 1.0 : 0.5; }
            ctx.drawImage(player.img, player.x, player.y, player.width, player.height);
            ctx.restore();
            // Dash Trail (Unchanged)
            player.dashParticles.forEach(p => { ctx.beginPath(); const alpha = (p.life / 20) * 0.5; ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`; ctx.arc(p.x, p.y, player.width * 0.3 * (p.life / 20), 0, Math.PI * 2); ctx.fill(); });
            // Laser Beam (Unchanged)
            if (player.isFiringLaser) { const laserDx = player.lastMoveDx; const laserDy = player.lastMoveDy; const eyeOffsetX = player.width * 0.22; const eyeOffsetY = -player.height * 0.05; const laserStartX = player.x + player.width / 2 + eyeOffsetX * (laserDx > 0 ? 1 : (laserDx < 0 ? -1 : 1)); const laserStartY = player.y + player.height / 2 + eyeOffsetY; const laserEndX = laserStartX + laserDx * player.laserRange; const laserEndY = laserStartY + laserDy * player.laserRange; ctx.beginPath(); ctx.moveTo(laserStartX, laserStartY); ctx.lineTo(laserEndX, laserEndY); ctx.strokeStyle = 'red'; ctx.lineWidth = player.laserWidth; ctx.shadowColor = 'rgba(255, 0, 0, 0.8)'; ctx.shadowBlur = 10; ctx.stroke(); ctx.beginPath(); ctx.moveTo(laserStartX, laserStartY); ctx.lineTo(laserEndX, laserEndY); ctx.strokeStyle = 'white'; ctx.lineWidth = player.laserWidth * 0.4; ctx.shadowBlur = 0; ctx.stroke(); ctx.shadowColor = 'transparent'; }

            // Rivals (Draw + Debug Logging)
            rivals.forEach((rival, index) => {
                if (!rival.isDestroyed) {
                    if (rival.img) {
                        ctx.drawImage(rival.img, rival.x, rival.y, rival.width, rival.height);
                    } else {
                        // Draw fallback yellow rectangle
                        ctx.fillStyle = '#f1c40f';
                        ctx.fillRect(rival.x, rival.y, rival.width, rival.height);
                    }
                    // Debug log position - remove later if needed
                    // console.log(`Drawing Rival ${index} at (${rival.x.toFixed(1)}, ${rival.y.toFixed(1)})`);
                } else {
                    // Optional: Log if a rival is skipped because it's destroyed
                    // console.log(`Skipping draw for destroyed Rival ${index}`);
                }
            });

            // Particles (Unchanged)
            particles.forEach(p => { const lifeRatio = Math.max(0, p.life / p.initialLife); const colorMatch = p.color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/); let r = 200, g = 200, b = 200, a = 0.8; if (colorMatch) { r = parseInt(colorMatch[1]); g = parseInt(colorMatch[2]); b = parseInt(colorMatch[3]); a = parseFloat(colorMatch[4] || '1'); } const greyVal = 128; const fadeFactor = 1 - lifeRatio; const currentR = Math.round(r * lifeRatio + greyVal * fadeFactor); const currentG = Math.round(g * lifeRatio + greyVal * fadeFactor); const currentB = Math.round(b * lifeRatio + greyVal * fadeFactor); const currentA = a * lifeRatio; ctx.fillStyle = `rgba(${currentR}, ${currentG}, ${currentB}, ${currentA})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius * lifeRatio, 0, Math.PI * 2); ctx.fill(); });
        }

        // --- Community Feedback --- (Unchanged)
        function triggerFeedback(eventType) { const messageData = feedbackMessages.find(m => m.trigger === eventType); if (!messageData) return; const currentApproval = parseInt(approvalMeter.value); const newApproval = Math.max(0, currentApproval + messageData.approval); approvalMeter.value = newApproval; const msgElement = document.createElement('div'); msgElement.className = 'feedback-message'; if (messageData.negative) { msgElement.classList.add('negative'); } msgElement.textContent = messageData.text; feedbackArea.appendChild(msgElement); while (feedbackArea.children.length > 5) { feedbackArea.removeChild(feedbackArea.firstChild); } setTimeout(() => { msgElement.classList.add('fade-out'); msgElement.addEventListener('transitionend', () => { if (msgElement.parentElement === feedbackArea) { feedbackArea.removeChild(msgElement); } }, { once: true }); }, 2000); if (messageData.sound) { playSound(messageData.sound, messageData.note || null, '8n'); } if (newApproval <= 0 && gameState !== 'gameOver') { triggerGameOver(); } }

        // --- Game Loop (Delta Time Implementation) ---
        function gameLoop(timestamp) { // Receive timestamp
            if (!lastTimestamp) {
                lastTimestamp = timestamp; // Initialize on first frame
            }
            // Calculate delta time, ensuring it's not excessively large (e.g., if tab was inactive)
            const deltaTime = Math.min((timestamp - lastTimestamp) / 1000, 0.1); // Max delta 100ms (10fps)
            lastTimestamp = timestamp;

            // Ensure joystick dimensions are calculated
            if (gameState === 'playing' && !joystickDimensionsCalculated && joystickArea.offsetWidth > 0) {
                joystickRadius = joystickArea.offsetWidth / 2;
                knobRadius = joystickKnob.offsetWidth / 2;
                maxJoystickDist = joystickRadius - knobRadius;
                if (maxJoystickDist > 0) {
                    joystickDimensionsCalculated = true;
                    console.log("Joystick dimensions calculated:", joystickRadius, maxJoystickDist);
                } else {
                     console.warn("Could not calculate valid joystick dimensions yet.");
                }
            }

            // Update laser button cooldown state
            if (gameState === 'playing') {
                const laserButton = document.getElementById('laser-button');
                if (laserButton) {
                    const now = Date.now();
                    const isOnCooldown = now - player.lastLaserTime < player.laserCooldown;
                    laserButton.classList.toggle('cooldown', isOnCooldown);
                }
            }

            if (gameState === 'playing') {
                update(deltaTime); // Pass deltaTime to update
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                console.log("Game loop paused - state:", gameState);
                // Reset timestamp when paused so delta isn't huge on resume
                lastTimestamp = 0;
            }
        }

        // --- Initial Setup Call ---
        window.onload = () => {
             console.log("Window loaded.");
             gameState = 'intro'; // Ensure game starts in intro state
             setupGame(currentLevel - 1).then(() => {
                 console.log("Initial game setup complete");
             });
             // Add touch listeners after DOM is loaded
             joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joystickActive = true; joystickArea.classList.add('active'); const touch = e.changedTouches[0]; joystickStartX = touch.clientX; joystickStartY = touch.clientY; }, { passive: false });
             joystickArea.addEventListener('touchmove', (e) => { e.preventDefault(); if (!joystickActive) return; if (!joystickDimensionsCalculated || maxJoystickDist <= 0) return; const touch = e.changedTouches[0]; const currentX = touch.clientX; const currentY = touch.clientY; const areaRect = joystickArea.getBoundingClientRect(); const areaCenterX = areaRect.left + areaRect.width / 2; const areaCenterY = areaRect.top + areaRect.height / 2; let dx = currentX - areaCenterX; let dy = currentY - areaCenterY; const dist = Math.sqrt(dx * dx + dy * dy); const angle = Math.atan2(dy, dx); const clampedDist = Math.min(dist, maxJoystickDist); const knobX = clampedDist * Math.cos(angle); const knobY = clampedDist * Math.sin(angle); joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`; const deadZone = maxJoystickDist * 0.15; if (clampedDist > deadZone) { const magnitude = Math.sqrt(dx * dx + dy * dy); joystickDx = dx / magnitude; joystickDy = dy / magnitude; /* joystickMagnitude removed */ } else { joystickDx = 0; joystickDy = 0; /* joystickMagnitude removed */ } }, { passive: false });
             joystickArea.addEventListener('touchend', (e) => { e.preventDefault(); if (!joystickActive) return; joystickActive = false; joystickArea.classList.remove('active'); joystickKnob.style.transform = `translate(-50%, -50%)`; joystickDx = 0; joystickDy = 0; /* joystickMagnitude removed */ }, { passive: false });
             // Add game area tap handler
             gameContainer.addEventListener('touchstart', handleGameAreaTap, { passive: false });
             console.log("Game area tap handler added.");
             
             // Add laser button handler
             const laserButton = document.getElementById('laser-button');
             laserButton.addEventListener('touchstart', (e) => {
                 e.preventDefault();
                 if (gameState === 'playing' && !player.isFiringLaser && Date.now() - player.lastLaserTime > player.laserCooldown) {
                     fireLaser();
                 }
             }, { passive: false });
             console.log("Laser button handler added.");
             
             // Setup intro touch handlers
             setupIntroTouchHandlers();
             console.log("Intro touch handlers added.");
        };

    </script>

</body>
</html>
